# JavaWeb
对于使用Java来作为后端主要语言的web服务，如果能拿到源码(jar等),就可以将其放入IDE里进行分析，每个页面每个功能都有其对应的对象，函数。大多数的常见通用手法也可以使用
## JWT
jwt是Java中类似于session和cookie功能的东西(它是一种token)，由于其有专门的签名，所以有防篡改的安全功能。
jwt格式如下：
`Header.Payload.Signature`
Header中包含了签名所使用的加密方式以及token的类型
Payload中包含了所要传递的信息
Signature中为对前面信息的签名，防止被篡改。
由于签名的存在，在生成jwt时，签名部分需要加密方式以及密钥来签名。如果前面的信息被修改，服务器在验证时就会发现其签名与实际信息的签名不一致。如果需要修改签名，就需要知道它的加密方式以及密钥。
### JWT攻击方式
#### 加密算法
##### 空加密算法
然而，jwt是支持空加密方式(None)的，即Header中的alg部分为None，且没有签名部分,这样，就可以提交任意的payload
想要提交这种jwt就必须要服务器端设置支持空加密算法(大概率不会这样)，否则是仍然不可行的。
`Header{"alg":"none"}.payload.`
##### 修改加密方式为HMAC
JWT中最常用的两种算法为`HMAC`和`RSA`。

`HMAC`是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code）的缩写，它是一种对称加密算法，使用相同的密钥对传输信息进行加解密。

`RSA`则是一种非对称加密算法，使用私钥加密明文，公钥解密密文。

在HMAC和RSA算法中，都是使用私钥对`signature`字段进行签名，只有拿到了加密时使用的私钥，才有可能伪造token。

现在我们假设有这样一种情况，一个Web应用，在JWT传输过程中使用RSA算法，密钥`pem`对JWT token进行签名，公钥`pub`对签名进行验证。

|                                                                                   |
| --------------------------------------------------------------------------------- |
| `{`<br><br>    `"alg"` `:` `"RS256"``,`<br><br>    `"typ"` `:` `"jwt"`<br><br>`}` |

通常情况下密钥`pem`是无法获取到的，但是公钥`pub`却可以很容易通过某些途径读取到，这时，将JWT的加密算法修改为HMAC，即

|                                                                                   |
| --------------------------------------------------------------------------------- |
| `{`<br><br>    `"alg"` `:` `"HS256"``,`<br><br>    `"typ"` `:` `"jwt"`<br><br>`}` |

同时使用获取到的公钥`pub`作为算法的密钥，对token进行签名，发送到服务器端。

服务器端会将RSA的公钥（`pub`）视为当前算法（HMAC）的密钥，使用HS256算法对接收到的签名进行验证。

参考2018CUMTCTF-Final-Web Paterbin：[https://skysec.top/2018/05/19/2018CUMTCTF-Final-Web/#Pastebin/](https://skysec.top/2018/05/19/2018CUMTCTF-Final-Web/#Pastebin/)
#### 爆破密钥
在已知加密方式的情况下，可以对密钥进行爆破：
未知密钥+已知的Header+已知的payload+签名
\=
爆破的密钥+已知的Header+已知的payload+使用爆破密钥生成的签名
对比签名是否相等
局限性是：
熟悉其加密方式
简单的密钥
相关工具：[c-jwt-cracker](https://github.com/brendan-rius/c-jwt-cracker)
#### 修改KID参数

`kid`是jwt header中的一个可选参数，全称是`key ID`，它用于指定加密算法的密钥

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5|`{`<br><br>    `"alg"` `:` `"HS256"``,`<br><br>    `"typ"` `:` `"jwt"``,`<br><br>    `"kid"` `:` `"/home/jwt/.ssh/pem"`<br><br>`}`|

因为该参数可以由用户输入，所以也可能造成一些安全问题。

##### 0x01 任意文件读取

`kid`参数用于读取密钥文件，但系统并不会知道用户想要读取的到底是不是密钥文件，所以，如果在没有对参数进行过滤的前提下，攻击者是可以读取到系统的任意文件的。

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5|`{`<br><br>    `"alg"` `:` `"HS256"``,`<br><br>    `"typ"` `:` `"jwt"``,`<br><br>    `"kid"` `:` `"/etc/passwd"`<br><br>`}`|

##### 0x02 SQL注入

`kid`也可以从数据库中提取数据，这时候就有可能造成SQL注入攻击，通过构造SQL语句来获取数据或者是绕过signature的验证

|   |   |
|---|---|
|1<br><br>2<br><br>3<br><br>4<br><br>5|`{`<br><br>    `"alg"` `:` `"HS256"``,`<br><br>    `"typ"` `:` `"jwt"``,`<br><br>    `"kid"` `:` `"key11111111' \| union select 'secretkey' -- "`<br><br>`}`|

##### 0x03 命令注入

对`kid`参数过滤不严也可能会出现命令注入问题，但是利用条件比较苛刻。如果服务器后端使用的是Ruby，在读取密钥文件时使用了`open`函数，通过构造参数就可能造成命令注入。

"/path/to/key_file|whoami"

对于其他的语言，例如php，如果代码中使用的是`exec`或者是`system`来读取密钥文件，那么同样也可以造成命令注入，当然这个可能性就比较小了。

#### 修改JKU/X5U参数

`JKU`的全称是"JSON Web Key Set URL"，用于指定一组用于验证令牌的密钥的URL。类似于`kid`，`JKU`也可以由用户指定输入数据，如果没有经过严格过滤，就可以指定一组自定义的密钥文件，并指定web应用使用该组密钥来验证token。

`X5U`则以URI的形式数允许攻击者指定用于验证令牌的**公钥证书或证书链**，与`JKU`的攻击利用方式类似。

#### 信息泄露

JWT保证的是数据传输过程中的完整性而不是机密性。

由于payload是使用`base64url`编码的，所以相当于明文传输，如果在payload中携带了敏感信息（如存放密钥对的文件路径），单独对payload部分进行`base64url`解码，就可以读取到payload中携带的信息。
## WebGoat
很好，现在去通关WebGoat吧。