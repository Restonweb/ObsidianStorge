# 枚举
对于国内环境，枚举的前期会使用[[
## 从外部枚举主机
这将是一个简短的部分，介绍如何查找从 Internet 响应的 IP。 在这种情况下，有一些 IP 范围（甚至可能是几个范围），只是为了找到哪些 IP 正在响应。
### ICMP
```sh
ping -c 1 199.66.11.4    # 1 echo request to a host
fping -g 199.66.11.0/24  # Send echo requests to ranges
nmap -PE -PM -PP -sn -n 199.66.11.0/24 #Send echo, timestamp requests and subnet mask requests
```
### 枚举TCP端口
发现所有类型的ICMP数据包都被过滤是很常见的。然后，要检查主机是否已启动，所能做的就是尝试查找打开的端口。每个主机有 65535 个端口，因此，如果有一个“大”范围，则无法测试每个主机的每个端口是否打开，这将花费太多时间。需要使用快速端口扫描仪（ masscan ）和更多使用的端口列表：
```sh
#Using masscan to scan top20ports of nmap in a /24 range (less than 5min)
masscan -p20,21-23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 199.66.11.0/24
```
也可以使用 `nmap` 执行此步骤，但它速度较慢，并且 `nmap` 无法识别有些主机。
### 枚举HTTP端口
专门扫HTTP服务时：
```sh
masscan -p80,443,8000-8100,8443 199.66.11.0/24
```
### 枚举UDP端口
还可以尝试检查某些 UDP 端口是否打开，以决定是否应该更加关注某个主机。 由于 UDP 服务通常不会对常规空 UDP 探测数据包做出任何数据响应，因此很难判断端口是否被过滤或打开。决定这一点的最简单方法是发送与正在运行的服务相关的数据包，由于不知道哪个服务正在运行，因此根据端口号尝试最有可能的：
```sh
nmap -sU -sV --version-intensity 0 -F -n 199.66.11.53/24
# The -sV will make nmap test each possible known UDP service packet
# The "--version-intensity 0" will make nmap only test the most probable
```
nmap 将测试 /24 范围内每个主机中的前 1000 个 UDP 端口，但即使仅此也需要 >20 分钟。如果需要最快的结果，可以使用 udp-proto-scanner ： `./udp-proto-scanner.pl 199.66.11.53/24` 这会将这些 UDP 探测器发送到其预期端口（对于 /24 范围，这只需要 1 分钟）：
```UDP服务探针
DNSStatusRequest、DNSVersionBindReq、NBTStat、NTPRequest、RPCCheck、SNMPv3GetRequest、chargen、citrix、daytime、db2、echo、gtpv1、ike、ms-sql、ms-sql-slam、netop、ntp、rpc、snmp-public、systat、tftp、time、xdmcp。
```
### 用SCTP发现端口
```sh
#Probably useless, but it's pretty fast, why not trying?
nmap -T4 -sY -n --open -Pn <IP/range>
```
## 从内部枚举主机
### 被动枚举
可以使用以下工具被动地发现已连接网络中的主机：
```sh
netdiscover -p
p0f -i eth0 -p -o /tmp/p0f.log
# Bettercap
net.recon on/off #Read local ARP cache periodically
net.show
set net.show.meta true #more info
```
### 主动枚举
注意，[[#从外部枚举主机]]中的任何手段也可以在此应用，但是因为与目的主机处于同一网络，可以执行更多的操作。
```sh
#ARP discovery
nmap -sn <Network> #ARP Requests (Discover IPs)
netdiscover -r <Network> #ARP requests (Discover IPs)

#NBT discovery
nbtscan -r 192.168.0.1/24 #Search in Domain

# Bettercap
net.probe on/off #Discover hosts on current subnet by probing with ARP, mDNS, NBNS, UPNP, and/or WSD
set net.probe.mdns true/false #Enable mDNS discovery probes (default=true)
set net.probe.nbns true/false #Enable NetBIOS name service discovery probes (default=true)
set net.probe.upnp true/false #Enable UPNP discovery probes (default=true)
set net.probe.wsd true/false #Enable WSD discovery probes (default=true)
set net.probe.throttle 10 #10ms between probes sent (default=10)

#IPv6
alive6 <IFACE> # Send a pingv6 to multicast.
```
#### 主动ICMP
- 如果 ping 子网广播地址，则 ping 应到达每个主机，它们可以响应： `ping -b 10.10.5.255`
- 通过ping网络广播地址，甚至可以在其他子网中找到主机： `ping -b 255.255.255.255`
- 使用 `nmap` 的 `-PE` 、 `-PP` 、 `-PM` 标志分别执行主机发现发送 ICMPv4 回显、时间戳和子网掩码请求：`nmap -PE -PM -PP -sn -vvv -n 10.12.5.0/24`
#### Wake On Lan
局域网唤醒用于通过网络消息打开计算机。用于打开计算机的魔术数据包只是一个提供 MAC Dst 的数据包，然后在同一 paket 中重复 16 次。 然后，这种数据包通常以以太网0x0842或UDP数据包的形式发送到端口9。 如果未提供 \[MAC]，则数据包将发送到广播以太网（广播 MAC 将是重复的 MAC）。
```
# Bettercap (if no [MAC] is specificed ff:ff:ff:ff:ff:ff will be used/entire broadcast domain)
wol.eth [MAC] #Send a WOL as a raw ethernet packet of type 0x0847
wol.udp [MAC] #Send a WOL as an IPv4 broadcast packet to UDP port 9
```
## 扫描主机
一旦枚举了要深入扫描的所有IP（外部或内部），就可以执行不同的操作。
### TCP扫描
- **Open** port: _SYN --> SYN/ACK --> RST_  
    开放端口：SYN --> SYN/ACK --> RST
- **Closed** port: _SYN --> RST/ACK_  
    关闭端口：SYN --> RST/ACK
- **Filtered** port: _SYN --> \[NO RESPONSE]_  
    过滤端口：SYN --> \[无响应]
- **Filtered** port: _SYN --> ICMP message_  
    过滤端口：SYN --> ICMP 消息
```
# Nmap fast scan for the most 1000tcp ports used
nmap -sV -sC -O -T4 -n -Pn -oA fastscan <IP> 
# Nmap fast scan for all the ports
nmap -sV -sC -O -T4 -n -Pn -p- -oA fullfastscan <IP> 
# Nmap fast scan for all the ports slower to avoid failures due to -T4
nmap -sV -sC -O -p- -n -Pn -oA fullscan <IP>

#Bettercap Scan
syn.scan 192.168.1.0/24 1 10000 #Ports 1-10000
```
### UDP扫描
扫描 UDP 端口有 2 个选项：
- 发送 UDP 数据包并检查响应 ICMP 是否无法访问（在一些情况下，ICMP 将被过滤，因此在端口关闭或打开的情况下，不会收到任何信息）。
- 发送格式化的数据报以从服务（例如，DNS、DHCP、TFTP 等，如 nmap-payloads 中列出）引发响应。如果收到响应，则端口处于打开状态。
**Nmap 将使用“-sV”混合这两个选项（UDP 扫描非常慢），但请注意 UDP 扫描比 TCP 扫描要慢：
```
# Check if any of the most common udp services is running
udp-proto-scanner.pl <IP> 
# Nmap fast check if any of the 100 most common UDP services is running
nmap -sU -sV --version-intensity 0 -n -F -T4 <IP>
# Nmap check if any of the 100 most common UDP services is running and launch defaults scripts
nmap -sU -sV -sC -n -F -T4 <IP> 
# Nmap "fast" top 1000 UDP ports
nmap -sU -sV --version-intensity 0 -n -T4 <IP>
# You could use nmap to test all the UDP ports, but that will take a lot of time
```
### SCTP扫描
SCTP（流控制传输协议）旨在与 TCP（传输控制协议）和 UDP（用户数据报协议）一起使用。其主要目的是促进通过 IP 网络传输电话数据，反映了信令系统 7 （SS7） 中的许多可靠性特性。 SCTP 是 SIGTRAN 协议系列的核心组件，旨在通过 IP 网络传输 SS7 信号。

对 SCTP 的支持由各种操作系统提供，例如 IBM AIX、Oracle Solaris、HP-UX、Linux、Cisco IOS 和 VxWorks，表明其在电信和网络领域的广泛接受和实用性。

nmap 提供两种不同的 SCTP 扫描：-sY 和 -sZ
```
# Nmap fast SCTP scan
nmap -T4 -sY -n -oA SCTFastScan <IP>
# Nmap all SCTP scan
nmap -T4 -p- -sY -sV -sC -F -n -oA SCTAllScan <IP>
```